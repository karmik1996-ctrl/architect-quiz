// Quiz questions data - All 175 questions with correct answers from PDF
// Extracted directly from PDF to preserve correct encoding

// CRITICAL: Prevent unwanted screen sharing dialog
// Block getDisplayMedia calls to prevent screen sharing dialog from appearing
if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
    const originalGetDisplayMedia = navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
    navigator.mediaDevices.getDisplayMedia = function() {
        return Promise.reject(new DOMException('Screen sharing is not allowed', 'NotAllowedError'));
    };
}

// ============================================
// CONTENT PROTECTION SYSTEM
// ============================================

// 1. Dynamic Watermark System
function createWatermark() {
    // Remove existing watermark if any
    const existing = document.getElementById('content-watermark');
    if (existing) existing.remove();
    
    // Get user identifier (payment code or session ID)
    const paymentCode = localStorage.getItem('paymentCode') || 'GUEST';
    const sessionId = sessionStorage.getItem('sessionId') || Date.now().toString(36);
    const timestamp = new Date().toISOString().split('T')[0];
    
    // Create watermark container
    const watermark = document.createElement('div');
    watermark.id = 'content-watermark';
    watermark.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 999999;
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    `;
    
    // Create repeated watermark pattern
    const watermarkText = `${paymentCode} | ${sessionId} | ${timestamp}`;
    
    // Add multiple watermark layers
    for (let layer = 0; layer < 3; layer++) {
        const layerDiv = document.createElement('div');
        layerDiv.style.cssText = `
            position: absolute;
            width: 200%;
            height: 200%;
            top: -50%;
            left: -50%;
            opacity: ${0.12 - layer * 0.02};
            pointer-events: none;
        `;
        
        for (let i = 0; i < 100; i++) {
            const text = document.createElement('div');
            text.textContent = watermarkText;
            text.style.cssText = `
                position: absolute;
                top: ${(i % 20) * 5}%;
                left: ${(i % 10) * 10}%;
                transform: rotate(${i * 3.6 + layer * 45}deg);
                white-space: nowrap;
                font-family: Arial, sans-serif;
                font-size: 18px;
                font-weight: bold;
                color: #ff0000;
                pointer-events: none;
            `;
            layerDiv.appendChild(text);
        }
        watermark.appendChild(layerDiv);
    }
    
    document.body.appendChild(watermark);
    return watermark;
}

// 2. Blur Content on Focus Loss
function setupBlurProtection() {
    // Blur on window blur
    window.addEventListener('blur', () => {
        document.body.style.filter = 'blur(20px)';
        document.body.style.transition = 'filter 0.3s ease';
    });
    
    // Remove blur on focus
    window.addEventListener('focus', () => {
        document.body.style.filter = 'none';
    });
    
    // Blur on visibility change (tab switch, minimize, etc.)
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            document.body.style.filter = 'blur(20px)';
        } else {
            document.body.style.filter = 'none';
        }
    });
    
    // Blur on page unload attempt
    window.addEventListener('beforeunload', () => {
        document.body.style.filter = 'blur(20px)';
    });
}

// Initialize content protection when payment is verified
function initializeContentProtection() {
    const paymentCode = localStorage.getItem('paymentCode');
    if (paymentCode) {
        // Create session ID if not exists
        if (!sessionStorage.getItem('sessionId')) {
            sessionStorage.setItem('sessionId', Date.now().toString(36) + Math.random().toString(36).substr(2, 9));
        }
        
        // Create watermark
        createWatermark();
        
        // Setup blur protection
        setupBlurProtection();
    }
}

// Initialize on page load if already authenticated
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        initializeContentProtection();
    });
} else {
    initializeContentProtection();
}

// Օգտագործված նյութեր
// ՔՇՕ – Քաղաքաշինության մասին ՀՀ օրենք
// ՃԳՄՕ – Ճարտարապետական գործունեության մասին ՀՀ օրենք
// ՔՕ – ՀՀ քաղաքացիական օրենսգիրք
// ՀՕ – ՀՀ հողային օրենսգիրք
// ՊՀՊՕ – Պատմության և մշակույթի անշարժ հուշարձանների ու պատմական միջավայրի պահպանության և օգտագործման մասին ՀՀ օրենք
// ԿՈ – ՀՀ կառավարության որոշում
// ՃԷԿ – Ճարտարապետների էթիկայի կանոններ
// ԼՄՀ – Լիազոր պետական մարմնի ղեկավարի հրաման

// Թեմաներ
// 1. Քաղաքաշինական գործունեության իրականացման ընթացակարգ (արտոնագրման Ա դաս)
//   1.1. Հողերի օտարում
//   1.2. Ինժեներաերկրաբանական հետազոտություններ
//   1.3. Կառուցապատման նպատակով թույլտվություններ
//   1.4. Նախագծային առաջադրանք
//   1.5. Կապալի պայմանագիր
//   1.6. Նախագծի փորձաքննություն
//   1.7. Շինարարության թույլտվություն
//   1.8. Շինարարության իրականացում
//   1.9. Շինարարության ավարտ
//   1.10. Քաղաքաշինական կադաստր
//   1.11. Քաղաքաշինական տեսչություն
//   1.12. Ճարտարապետների արտոնագրում
//   1.13. Ճարտարապետի իրավունքներ
//   1.14. Ճարտարապետի էթիկա
// 2. Ճարտարապետաշինարարական նախագծերի մշակում (արտոնագրման Ա և Ա1 դասեր)
// 3. Քաղաքաշինական ծրագրային (տարածական պլանավորման) փաստաթղթերի մշակում (արտոնագրման Բ դաս)
// 4. Հուշարձանների պահպանություն

const quizData = [
    {
        topic: "1.1. Հողերի օտարում",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Համայնքային սեփականության հողերը քաղաքաշինական գործունեության նպատակով օտարելու դեպքում աճուրդի կազմակերպման փաթեթում ներառվում է",
        answers: [
            "Համայնքի ավագանու որոշումը հողամասի օտարման մասին",
            "Սահմանված կարգով կազմված ճարտարապետահատակագծային առաջադրանքի նախագիծը",
            "Նախագծային առաջադրանքը",
        ],
        correct: 1 // Question 1
    },
    {
        topic: "1.1. Հողերի օտարում",
        materials: "օգտագործված նյութեր ՀՕ, հոդվ. 60",
        question: "Քաղաքացիներին և իրավաբանական անձանց սեփականության իրավունքով չեն կարող օտարվել համայնքային սեփականության",
        answers: [
            "Հասարակական կառուցապատման հողերը",
            "Արտադրական նշանակության հողերը",
            "Ընդհանուր օգտագործման հողերը",
            "Խառը կառուցապատման հողերը",
        ],
        correct: 2 // Question 2
    },
    {
        topic: "1.1. Հողերի օտարում",
        materials: "օգտագործված նյութեր ՀՕ, հոդվ. 60, ԿՈ, 12.04.2001, N286",
        question: "Ջրային օբյեկտների և ավազանների առափնյա շերտերը քաղաքացիներին և իրավաբանական անձանց կարող են տրամադրվել",
        answers: [
            "Սեփականության իրավունքով",
            "Մշտական օգտագործման իրավունքով",
            "Կառուցապատման իրավունքով",
            "Անհատական օգտագործման իրավունքով",
        ],
        correct: 2 // Question 3
    },
    {
        topic: "1.1. Հողերի օտարում",
        materials: "օգտագործված նյութեր ԿՈ,19.03.2015, N596-Ն",
        question: "Համայնքի տարածական պլանավորման փաստաթղթերի բացակայության դեպքում կառուցապատման ընթացակարգը",
        answers: [
            "Չի իրականացվում",
            "Իրականացվում է Հայաստանի Հանրապետության կառավարության որոշմամբ սահմանված կարգով",
            "Սահմանվում է միջգերատեսչական հանձնաժողովի որոշմամբ",
        ],
        correct: 1 // Question 4
    },
    {
        topic: "1.2. Ինժեներաերկրաբանական հետազոտություններ",
        materials: "օգտագործված նյութեր ԿՈ,29.12,2011, N1920-Ն",
        question: "Քաղաքաշինական համակցված ծրագրային փաստաթղթի ելակետային նյութերի ցանկը ներառում է",
        answers: [
            "Տարածքի սահմանված կարգով հաստատված սեյսմիկ շրջանացման քարտեզը (ուրվագիծը), ինժեներաերկրաբանական շրջանացման (պայմանների) քարտեզը, գեոդեզիական հանույթները",
            "Կառուցապատման էսքիզային նախագիծը",
            "Համայնքի ղեկավարի կողմից կազմված և հաստատված առաջադրանքը",
        ],
        correct: 0 // Question 5
    },
    {
        topic: "1.2. Ինժեներաերկրաբանական հետազոտություններ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ինժեներաերկրաբանական հետազոտությունների նյութերի փորձաքննությունն իրականացվում է",
        answers: [
            "Նախագծային աշխատանքների կապալի պայմանագրին համապատասխան",
            "Հայաստանի Հանրապետության կառավարության որոշմամբ սահմանված կարգով",
            "Բնագավառի պետական լիազոր մարմնի կողմից",
        ],
        correct: 1 // Question 6
    },
    {
        topic: "1.3. Կառուցապատման նպատակով թույլտվություններ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Որն՞ է կառուցապատման նպատակով թույլտվություններ և այլ փաստաթղթեր տրամադրող իրավասու մարմինը",
        answers: [
            "Համայնքի ավագանին",
            "Համայնքի ղեկավարը (Երևան քաղաքում՝օրենքով նախատեսված դեպքերում՝նաև վարչական շրջանի ղեկավարը)",
            "Լիցենզավորման կենտրոնը",
        ],
        correct: 1 // Question 7
    },
    {
        topic: "1.3. Կառուցապատման նպատակով թույլտվություններ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ճարտարապետահատակագծային առաջադրանքը կազմում է",
        answers: [
            "Պատվիրատուն",
            "Համայնքի ղեկավարը",
            "Համայնքի ավագանին",
            "Նախագծողը",
        ],
        correct: 1 // Question 8
    },
    {
        topic: "1.3. Կառուցապատման նպատակով թույլտվություններ",
        materials: "օգտագործված նյութեր ՔՇՕ, Հոդվ. 22.1,",
        question: "Ճարտարապետահատակագծային առաջադրանքը սահմանում է",
        answers: [
            "Քաղաքաշինական օբյեկտի ճարտարապետաշինարարական նախագծային փաստաթղթերի կազմի և բովանդակությանը ներկայացվող պահանջները",
            "Քաղաքաշինական գործունեության օբյեկտին ներկայացվող նախագծման և քաղաքաշինական պարտադիր պայմաններ,այդ թվում՝ ինժեներական ենթակառուցվածքների նախագծման տեխնիկական պայմաններըև սահմանափակումները",
            "Կառուցապատման կանոնները",
        ],
        correct: 1 // Question 9
    },
    {
        topic: "1.3. Կառուցապատման նպատակով թույլտվություններ",
        materials: "օգտագործված նյութեր ՔՇՕ, Հոդվ. 22.1,",
        question: "Ճարտարապետահատակագծային առաջադրանքը տրվում է, ելնելով",
        answers: [
            "Համայնքի հողերի օգտագործման սխեմայից",
            "Հաստատված տարածական պլանավորման փաստաթղթերի և քաղաքաշինական կանոնադրության պահանջներից",
            "Համայնքի ավագանու որոշումից",
        ],
        correct: 1 // Question 10
    },
    {
        topic: "1.3. Կառուցապատման նպատակով թույլտվություններ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ճարտարապետահատակագծային առաջադրանքի գործողության ժամկետը չի կարող գերազանցել միջինից բարձր ռիսկայնության աստիճանի (III կատեգորիայի) օբյեկտների համար",
        answers: [
            "Մեկ տարին",
            "Մեկուկես տարին",
            "Երկու տարին",
        ],
        correct: 1 // Question 11
    },
    {
        topic: "1.4. Նախագծային առաջադրանք",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նախագծային առաջադրանքը կազմում է",
        answers: [
            "Համայնքի ղեկավարը,",
            "Կառուցապատողը,",
            "Ճարտարապետը",
        ],
        correct: 1 // Question 12
    },
    {
        topic: "1.4. Նախագծային առաջադրանք",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն [ՃԻՇՏ]",
        question: "Նախագծային առաջադրանքը չի կարող հակասել",
        answers: [
            "Համայնքի գլխավոր հատակագծին,",
            "Համայնքի ավագանու որոշմանը,",
            "Նախագծման թույլտվությանը",
        ],
        correct: 2 // Question 13
    },
    {
        topic: "1.4. Նախագծային առաջադրանք",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Տեխնիկական բնութագիրը պետք է ներառի",
        answers: [
            "Ճարտարապետական լուծումներին ներկայացվող պահանջներ,",
            "Համայնքի գլխավոր հատակագծով սահմանված պահանջներ,",
            "Նախագծի փորձաքննությանը ներկայացվող պահանջներ",
        ],
        correct: 0 // Question 14
    },
    {
        topic: "1.5. Կապալի պայմանագիր",
        materials: "օգտագործված նյութեր ՔՕ,հոդվ. 700,2.",
        question: "Կապալի պայմանագիրը",
        answers: [
            "Կնքվում է գրավոր կամ բանավոր",
            "Կնքվում է գրավոր",
            "Կնքվում է բանավոր",
        ],
        correct: 1 // Question 15
    },
    {
        topic: "1.5. Կապալի պայմանագիր",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նշված փաստաթղթերից ո՞րը չի հանդիսանում նախագծային փաստաթղթերի մշակման կապալի պայմանագրի հավելված",
        answers: [
            "ճարտարապետաշինարարական նախագիծ,",
            "ճարտարապետահատակագծային առաջադրանք (նախագծման թույլտվություն)",
            "Նախագծային առաջադրանք",
        ],
        correct: 0 // Question 16
    },
    {
        topic: "1.5. Կապալի պայմանագիր",
        materials: "օգտագործված նյութեր ՔՕ, հոդվ.440,2",
        question: "Թույլատրվում է արդյոք նախագծային աշխատանքների կապալի պայմանագրի կնքումից հետո փոփոխել դրա գինը",
        answers: [
            "Այո, կողմերից մեկի պահանջով",
            "Ոչ",
            "Միայն պայմանագրով կամ օրենքով նախատեսված դեպքերում և պայմաններով",
        ],
        correct: 2 // Question 17
    },
    {
        topic: "1.6. Նախագծի փորձաքննություն",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նախագծողի ընտրությունը ճարտարապետական հրապարակային մրցույթով կատարվում է",
        answers: [
            "Կառավարության սահմանած դեպքերում,",
            "Բնագավառի լիազոր մարմնի որոշմամբ,",
            "Օրենքով սահմանված դեպքերում կամ կառուցապատողի հայեցողությամբ",
        ],
        correct: 2 // Question 18
    },
    {
        topic: "1.6. Նախագծի փորձաքննություն",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Փորձագիտական եզրակացությունը քանի՞ հնարավոր սահմաններով կարող է եզրափակվել",
        answers: [
            "Երեք",
            "Չորս",
            "Հինգ",
        ],
        correct: 0 // Question 19
    },
    {
        topic: "1.6. Նախագծի փորձաքննություն",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ.17,18",
        question: "Ճարտարապետաշինարարական նախագծային փաստաթղթերը հաստատում է",
        answers: [
            "Համայնքի ղեկավարը",
            "Քաղաքաշինական օբյեկտի սեփականատերը կամ նրա լիազորած անձը",
            "Կապալառուն",
        ],
        correct: 1 // Question 20
    },
    {
        topic: "1.6. Նախագծի փորձաքննություն",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նախագծային փաստաթղթերը համարվում են հաստատված",
        answers: [
            "Փորձաքննություն անցնելուց հետո",
            "Կապալի պայմանագրով նախատեսված ժամկետը լրանալու պահին",
            "Իրավասու մարմնի կողմից համաձայնեցվելուց և շինարարության թույլտվությունը տրամադրվելուց հետո",
        ],
        correct: 2 // Question 21
    },
    {
        topic: "1.6. Նախագծի փորձաքննություն",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Հաստատված նախագծային փաստաթղթերում փոփոխությունները կատարվում են",
        answers: [
            "Կառավարության որոշմամբ սահմանված ընթացակարգերին համապատասխան",
            "Պատվիրատուի և նախագծողի փոխադարձ համաձայնությամբ\` ներկայացնելով համայնքի ղեկավարի համաձայնեցմանը",
            "Հեղինակի կողմից և հաստատվում պատվիրատուի կողմից",
        ],
        correct: 0 // Question 22
    },
    {
        topic: "1.6. Նախագծի փորձաքննություն",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նախագծային փաստաթղթերը չեն համաձայնեցվում, եթե",
        answers: [
            "Դրանք հակասում են համայնքի գլխավոր հատակագծին,",
            "Դրանք չեն համապատասխանում նախագծման թույլտվությամբ սահմանված պայմաններին և սահմանափակումներին,",
            "Դրանք չեն համապատասխանում նախագծային առաջադրանքին",
        ],
        correct: 1 // Question 23
    },
    {
        topic: "1.7. Շինարարության թույլտվություն",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Որ՞ փաստաթուղթն է հաստատում կառուցապատողի\` որոշակի շինարարական գործունեություն իրականացնելու իրավունքը",
        answers: [
            "Ճարտարապետահատակագծային առաջադրանքը",
            "Աշխատանքային նախագիծը",
            "Շինարարության թույլտվությունը",
            "Համայնքի ավագանու որոշումը",
        ],
        correct: 2 // Question 24
    },
    {
        topic: "1.7. Շինարարության թույլտվություն",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ.23",
        question: "Շինարարության թույլտվությունը տալիս է",
        answers: [
            "Համայնքի գլխավոր ճարտարապետը,",
            "Համայնքի ավագանին,",
            "Համայնքի ղեկավարը՝ կառավարության սահմանած կարգով,",
            "Քաղաքաշինական տեսչությունը",
        ],
        correct: 2 // Question 25
    },
    {
        topic: "1.7. Շինարարության թույլտվություն",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ.24",
        question: "Քանդման թույլտվությունը տալիս է",
        answers: [
            "Համայնքի ղեկավարը՝ կառավարության սահմանած կարգով.",
            "Համայնքի գլխավոր ճարտարապետը",
            "Համայնքի ավագանին,",
            "Քաղաքաշինական տեսչությունը",
        ],
        correct: 0 // Question 26
    },
    {
        topic: "1.7. Շինարարության թույլտվություն",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "4-րդ ռիսկայնության աստիճանի կատեգորիայի օբյեկտների դեպքում ինչ ժամկետում է տրվում շինարարության թույլտվությունը",
        answers: [
            "10-օրյա ժամկետում",
            "15-օրյա ժամկետում",
            "20-օրյա ժամկետում",
        ],
        correct: 1 // Question 27
    },
    {
        topic: "1.7. Շինարարության թույլտվություն",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ոչ հիﬓական օբյեկտների իրականացման համար",
        answers: [
            "Տրվում է շինարարության թույլտվություն,",
            "Տրվում է տեղադրման թույլտվություն,",
            "Թույլտվություն չի պահանջվում",
        ],
        correct: 1 // Question 28
    },
    {
        topic: "1.8. Շինարարության իրականացում",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նոր կառուցվող շենքերի, շինությունների համար շինարարության թույլտվությամբ շինարարության ավարտի ժամկետ սահմանվում է",
        answers: [
            "Ոչ ավելի նախագծային փաստաթղթերում նախատեսված ժամկետների 1.5-ապատիկից",
            "Ոչ ավելի նախագծային փաստաթղթերում նախատեսված ժամկետների 2-ապատիկից",
            "Ոչ ավելի նախագծային փաստաթղթերում նախատեսված ժամկետների 2.5-ապատիկից",
        ],
        correct: 0 // Question 29
    },
    {
        topic: "1.8. Շինարարության իրականացում",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Շինարարության թույլտվության հիման վրա ցանկացած շինարարական և զուգահեռ աշխատանք կարող է իրականացվել",
        answers: [
            "Համայնքի ղեկավարի որոշմամբ սահմանված պահանջներին համապատասխան",
            "Կառավարության սահմանած կարգով հաստատված նախագծային փաստաթղթերի, նորմատիվատեխնիկական փաստաթղթերի պահանջներին և Հայաստանի Հանրապետության օրենսդրությանը համապատասխան,",
            "Շինարարության կապալի պայմանագրին համապատասխան",
        ],
        correct: 1 // Question 30
    },
    {
        topic: "1.8. Շինարարության իրականացում",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 6",
        question: "Օբյեկտի գործնական իրականացման ընթացքում կառուցապատողը պարտավոր է",
        answers: [
            "Համայնքի ղեկավարին տեղեկություններ տրամադրել շինարարության ընթացքի մասին,",
            "Ապահովել շինարարության որակի տեխնիկական հսկողությունը՝ օրենքով սահմանված կարգով",
            "Ճարտարապետին տրամադրել աշխատանքային տարածք",
        ],
        correct: 1 // Question 31
    },
    {
        topic: "1.9. Շինարարության ավարտ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Որ՞ փաստաթուղթն է հավաստում ավարտված շինարարական օբյեկտի գործառնական նշանակությամբ շահագործման իրավունքը",
        answers: [
            "Ավարտական ակտը",
            "Շահագործման թույլտվությունը",
            "Համայնքի ղեկավարի որոշումը",
        ],
        correct: 1 // Question 32
    },
    {
        topic: "1.9. Շինարարության ավարտ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ավարտական ակտը (շահագործման թույլտվությունը), բացառությամբ բարձրագույն ռիսկայնության աստիճանի (V կատեգորիայի) դասակարգում ունեցող օբյեկտների, տալիս է",
        answers: [
            "Համայնքի ղեկավարը",
            "Այդ նպատակով ստեղծված հանձնաժողովը",
            "Լիազոր մարմինը",
        ],
        correct: 0 // Question 33
    },
    {
        topic: "1.9. Շինարարության ավարտ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ընդունող հանձնաժողովը ձևավորվում և ղեկավարվում է, բացառությամբ բարձրագույն ռիսկայնության աստիճանի (V կատեգորիայի) դասակարգում ունեցող օբյեկտների)",
        answers: [
            "Համայնքի ղեկավարը,",
            "Կառուցապատողը",
            "Կապալառու կազմակերպության ներկայացուցիչը",
        ],
        correct: 1 // Question 34
    },
    {
        topic: "1.9. Շինարարության ավարտ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Համայնքի ղեկավարն ավարտական ակտը (շահագործման թույլտվությունը) ձևակերպելուց հետո 3-օրյա ժամկետում դրա մասին ծանուցում է",
        answers: [
            "Համապատասխան մարզպետին (բացառությամբ Երևան քաղաքի) և Հայաստանի Հանրապետության քաղաքաշինության, տեխնիկական և հրդեհային անվտանգության տեսչական մարմնի տարածքային բաժնին",
            "Հայաստանի Հանրապետության քաղաքաշինության կոմիտեին",
            "Կառուցապատողին",
        ],
        correct: 0 // Question 35
    },
    {
        topic: "1.10. Քաղաքաշինական կադաստր",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 20",
        question: "Պետական քաղաքաշինական կադաստրը",
        answers: [
            "Պետական տեղեկատվական համակարգ է",
            "Հիմք է գույքային իրավունքների պետական գրանցման համար",
            "Հիմք վիճելի հարցերի լուծման համար",
        ],
        correct: 0 // Question 36
    },
    {
        topic: "1.10. Քաղաքաշինական կադաստր",
        materials: "օգտագործված նյութեր ԿՈ, 31.12.1999, N802",
        question: "Քաղաքաշինական կադաստրի տվյալների հաշվառումը կատարվում է",
        answers: [
            "Ըստ լիազոր մարմնի սահմանած կարգի,",
            "Ըստ օբյեկտների բնույթի,",
            "Ըստ վարչատարածքային բաժանման՝ համայնքի, մարզ, հանրապետություն",
        ],
        correct: 2 // Question 37
    },
    {
        topic: "1.10. Քաղաքաշինական կադաստր",
        materials: "օգտագործված նյութեր ԿՈ, 31.12.1999, N802",
        question: "Քաղաքաշինական կադաստրի տեղեկությունները հաշվառվում են",
        answers: [
            "Կադաստրային գրանցամատյաններում,",
            "Քաղաքաշինության բնագավառի լիազոր մարմնի գրանցամատյաններում,",
            "քաղաքաշինական մատյաններում (համայնքի, մարզի, Հայաստանի Հանրապետության), որոնք են քաղաքաշինական գործունեության օբյեկտների քաղաքաշինական անձնագրեր",
        ],
        correct: 2 // Question 38
    },
    {
        topic: "1.11. Քաղաքաշինական տեսչություն",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 26",
        question: "Թվարկվածներից ո՞րը չի հանդիսանում քաղաքաշինության բնագավառի տեսչական մարմնի իրավասություն",
        answers: [
            "Վերահսկում է քաղաքաշինական գործունեության բնագավառում իրավական ակտերի, քաղաքաշինական փաստաթղթերի, նորմատիվ-տեխնիկական փաստաթղթերի պահանջների կատարումը,",
            "Վերահսկում է համայնքների ղեկավարների գործունեությունը քաղաքաշինության բնագավառում,",
            "Քաղաքաշինության բնագավառում հայտնաբերված խախտումների վերացման ուղղությամբ տալիս է պարտադիր կատարման հրահանգներ և ցուցումներ, հետևում է դրանց իրականացմանը",
        ],
        correct: 1 // Question 39
    },
    {
        topic: "1.11. Քաղաքաշինական տեսչություն",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 26",
        question: "Թվարկվածներից ո՞րը չի հանդիսանում համայնքի ղեկավարի իրավասություն",
        answers: [
            "Վերահսկում է կառուցապատողներին տրված ճարտարապետահատակագծային առաջադրանքների, բնակավայրերի քաղաքաշինական կանոնադրության պահանջների կատարմանը,",
            "Վերահսկում է նորմատիվ-տեխնիկական փաստաթղթերի պահանջների կատարումը, Գ. Կանխարգելում, կասեցնում է ինքնակամ շինարարության դեպքերը և օրենքով սահմանված կարգով ապահովում է դրանց հետևանքների վերացումը",
        ],
        correct: 0 // Question 40
    },
    {
        topic: "1.12. Ճարտարապետների արտոնագրում",
        materials: "օգտագործված նյութեր ՃԳՄՕ, հոդվ.14,15",
        question: "Ճարտարապետի կամ ճարտարագետ կոնստրուկտորի արտոնագիր ստանալու համար թվարկված պայմաններից որն անհրաժեշտ չէ",
        answers: [
            "Բակալավրի կրթական աստիճան և հինգ տարվա աշխատանքային փորձառություն,",
            "Մագիստրոսի աստիճան և առնվազն երկու տարվա աշխատանքային փորձառություն,",
            "Մասնակցություն հանրապետական կամ միջազգային ճարտարապետական մրցույթներին",
        ],
        correct: 2 // Question 41
    },
    {
        topic: "1.12. Ճարտարապետների արտոնագրում",
        question: "Ճարտարապետների արտոնագրման համար",
        answers: [
            "Սահմանված է արտոնագրի երկու դաս,",
            "Սահմանված է արտոնագրի երեք դաս,",
            "դասեր սահմանված չեն",
        ],
        correct: 1 // Question 42
    },
    {
        topic: "1.12. Ճարտարապետների արտոնագրում",
        materials: "օգտագործված նյութեր ՃԳՄՕ, հոդվ.17",
        question: "Արտոնագրի գործողությունը դադարեցվում է",
        answers: [
            "Ճարտարապետների պալատի որակավորման հանձնաժողովի որոշմով,",
            "Պալատի նախագահի որոշմով,",
            "Լիազորված մարմնի ղեկավարի հրամանով՝ խորհրդի որոշման հիման վրա",
        ],
        correct: 2 // Question 43
    },
    {
        topic: "1.12. Ճարտարապետների արտոնագրում",
        materials: "օգտագործված նյութեր ՃԳՄՕ, հոդվ.18",
        question: "Արտոնագրի գործողությունը կասեցվում է",
        answers: [
            "Լիազորված մարմնի ղեկավարի հրամանով,",
            "Պալատի նախագահի որոշմամբ,",
            "Պալատի խորհրդի որոշմամբ՝ արտոնագրման հանձնաժողովի եզրակացության հիման վրա",
        ],
        correct: 2 // Question 44
    },
    {
        topic: "1.13. Ճարտարապետի իրավունքներ",
        materials: "օգտագործված նյութեր ՃԳՄՕ, հոդվ. 13",
        question: "Որ իրավական ակտով են սահմանված ճարտարապետի իրավունքները և պարտականությունները",
        answers: [
            "«Ճարտարապետական գործունեության մասին» ՀՀ օրենքով",
            "«Քաղաքաշինության մասին» ՀՀ օրենքով",
            "ՀՀ կառավարության որոշմով",
            "Ճարտարապետների պալատի կանոնադրությամբ",
        ],
        correct: 0 // Question 45
    },
    {
        topic: "1.13. Ճարտարապետի իրավունքներ",
        materials: "օգտագործված նյութեր ՃԳՄՕ, հոդվ. 13",
        question: "ճարտարապետը իրավունք չունի",
        answers: [
            "Մշակելու քաղաքաշինական փաստաթղթեր կամ մասնակցելու դրանց մշակմանը",
            "Կառուցվող օբյեկտի շինարարության ընթացքում իրականացնել հեղինակային հսկողություն, մասնակցել ավարտված օբյեկտի ընդունմանը",
            "Միջամտել կառուցապատողի գործունեությանը",
            "Համակարգել քաղաքաշինական փաստաթղթերի բաժինների մշակումը",
        ],
        correct: 2 // Question 46
    },
    {
        topic: "1.13. Ճարտարապետի իրավունքներ",
        materials: "օգտագործված նյութեր ՃԳՄՕ, հոդվ. 13",
        question: "Ճարտարապետը պարտավոր չէ",
        answers: [
            "Պահպանել էթիկայի կանոնների պահանջները",
            "Պահպանել Հայաստանի Հանրապետության օրենսդրության, տարածական պլանավորման փաստաթղթերի, նորմատիվ-տեխնիկական փաստաթղթերի և նախագծման թույլտվության պահանջները և պայմանները",
            "Մասնակցել տարածական պլանավորման փաստաթղթերի մշակման տեխնիկական բնութագրի կազմմանը",
        ],
        correct: 2 // Question 47
    },
    {
        topic: "1.14. Ճարտարապետի էթիկա",
        question: "Թվարկվածներից ո՞րը չի հանդիսանում ճարտարապետի էթիկայի և վարքագծի ոլորտ",
        answers: [
            "պարտավորություններ մասնագիտության առջև,",
            "պարտավորություններ ղեկավարության առջև,",
            "պարտավորություններ գործընկերների առջև,",
            "պարտավորություններ պատվիրատուի առջև",
        ],
        correct: 1 // Question 48
    },
    {
        topic: "1.14. Ճարտարապետի էթիկա",
        question: "Թվարկվածներից որը չի հանդիսանում պատվիրատուի առջև ճարտարապետի պարտավորություն",
        answers: [
            "Ճարտարապետը հոնորար կամ եկամուտ պետք է ստանա միայն պատվերի ձևակերպման մասին գրավոր պայմանագրի հիման վրա",
            "Ճարտարապետը չպետք է կիրառի խրախուսման որևէ ձև պատվերն ստանալու դիմաց",
            "Ճարտարապետը պարտավոր է պահպանել պատվիրատուի գործերի մասին գաղտնապահությունը և դրանց վերաբերյալ տեղեկություն տալ միայն նրա հետ նախապես համաձայնեցնելուց հետո, բացառությամբ դատարանի կողմից պահանջներ կայացնելու դեպքերի",
            "Ճարտարապետը չպետք է մասնակցի այն ճարտարապետական մրցույթին, որը ՃՄՄ կամ ՀՃՄ կողմից հայտարարվել է անընդունելի",
        ],
        correct: 3 // Question 49
    },
    {
        topic: "1.14. Ճարտարապետի էթիկա",
        question: "Թվարկվածներից որը չի հանդիսանում գործընկերների առջև ճարտարապետի պարտավորություն",
        answers: [
            "Հրավիրված լինելով իր կարծիքն արտահայտել այլ ճարտարապետի աշխատանքի վերաբերյալ, ճարտարապետը պետք է տեղեկացնի այդ մասին տվյալ ճարտարապետին, բացառությամբ այն դեպքի, երբ դա կարող է վնասել նախատեսված կամ ընթացող դատավարությանը:",
            "Ճարտարապետը պարտավոր է ապահովել իր աշխատակիցների և աշխատողների պատշաճ աշխատանքային պայմանները, արդարացի վարձատրությունը և նպաստել նրանց մասնագիտական աճին:",
            "Ճարտարապետը, հարկ եղած դեպքերում, պարտավոր է մասնակցել հասարակական գործունեության որպես քաղաքացի և որպես արհեստավարժ անձ, և նպաստել հանրության համար ճարտարապետական խնդիրների պարզաբանման",
            "Ճարտարապետը չպետք է յուրացնի այլ անձի մտավոր սեփականությունը կամ ապօրինաբար օգտվի այլ ճարտարապետի գաղափարներից, առանց հղում անելու տվյալ ճարտարապետին կամ գաղափարի հեղինակին",
        ],
        correct: 2 // Question 50
    },
    {
        topic: "1.14. Ճարտարապետի էթիկա",
        question: "Քաղաքաշինության բնագավառում Հայաստանի Հանրապետության կառավարության իրավասությունը",
        answers: [
            "Սահմանում է քաղաքաշինական փաստաթղթերի մշակման և հաստատման կարգերը.",
            "Ապահովում է քաղաքաշինական նախագծային փաստաթղթերի շահագրգիռ կողմերի հետ համաձայնեցումը",
            "Օրենքով սահմանված կարգով իրականացնում է հայաստանի հանրապետության տարածքում քաղաքաշինական գործունեության պետական տեսչական վերահսկողությունը ՔՇՕ, հոդվ.10",
        ],
        correct: 0 // Question 51
    },
    {
        topic: "1.15.Մասնագիտական հանրության և պետական ինքնակառավարման մարﬕնների հարաբերություններ",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 10",
        question: "Քաղաքաշինության բնագավառում Հայաստանի Հանրապետության կառավարության իրավասությունը",
        answers: [
            "Սահմանում է քաղաքաշինական փաստաթղթերի մշակման ու հաստատման կարգերը",
            "Ապահովում է քաղաքաշինական նախագծային փաստաթղթերի շահագրգիռ կողմերի հետ համաձայնեցումը",
            "Օրենքով սահմանված կարգով իրականացնում է Հայաստանի Հանրապետության տարածքում քաղաքաշինական գործունեության պետական տեսչական վերահսկողությունը",
        ],
        correct: 0 // Question 52
    },
    {
        topic: "1.15.Մասնագիտական հանրության և պետական ինքնակառավարման մարﬕնների հարաբերություններ",
        materials: "օգտագործված նյութեր ՃԳՄՕ, հոդվ. 5",
        question: "Ճարտարապետների պալատը իրավունք չունի",
        answers: [
            "Ներկայացնել և պաշտպանել իր անդամների իրավունքները և օրինական շահերը պետական, տեղական ինքնակառավարման մարմինների, կազմակերպությունների հետ հարաբերություններում",
            "Հանդես գալ օրենսդրական նախաձեռնությամբ",
            "Մասնագիտական եզրակացություն ներկայացնել ՀՀ օրենսդիր և գործադիր մարմիններին քննարկվող՝ քաղաքաշինության օրենսդրությանն առնչվող նախագծերի վերաբերյալ",
            "Մասնակցել ճարտարապետների իրավունքներին, օրինական շահերը շոշափող օրենքների, իրավական այլ ակտերի մշակմանը, քննարկմանը ԳԼՈՒԽ 2 ՃԱՐՏԱՐԱՊԵՏԱՇԻՆԱՐԱՐԱԿԱՆ ՆԱԽԱԳԾԵՐԻ ՄՇԱԿՈՒՄ",
        ],
        correct: 1 // Question 53
    },
    {
        topic: "2.1.Ճարտարապետաշինարարական նախագծային փաստաթղթերի համակարգը",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 17",
        question: "Թվարկվածերից որը չի հանդիսանում ճարտարապետաշինարարական նախագիծ",
        answers: [
            "Կառուցապատման նախագիծը",
            "Արտադրական կարողությունների տեղաբաշխման նախագիծը",
            "Շենքերի կառուցման, վերակառուցման, վերականգնման նախագծերը",
            "Ինժեներական և տրանսպորտային ենթակառուցվածքների և դրանց մասերի նախագծերը",
        ],
        correct: 1 // Question 54
    },
    {
        topic: "2.2 Ճարտարապետաշինարարական նախագծային փաստաթղթերի համակարգը",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ճարտարապետաշինարարական նախագծային փաստաթղթերի կազմին և բովանդակությանը ներկայացվող պահանջները սահմանվում են",
        answers: [
            "«Քաղաքաշինության մասին» ՀՀ օրենքով",
            "Կառավարության որոշմամբ",
            "Բնագավառի պետական լիազորված մարմնի գերատեսչական ակտով",
        ],
        correct: 2 // Question 55
    },
    {
        topic: "2.2.Կառուցապատման նախագծեր",
        materials: "օգտագործված նյութեր ԿՈ, 02.05.2003, N608-Ն",
        question: "Կառուցապատման նախագծերի գրաֆիկական մասերը մշակվում են",
        answers: [
            "1:200 և 1:500 մասշտաբներով",
            "1:500 և 1:1000 մասշտաբներով",
            "1:1000 և 1:2000 մասշտաբներով",
        ],
        correct: 1 // Question 56
    },
    {
        topic: "2.3.Նախագծային առաջադրանք, տեխնիկական բնութագիր,",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նախագծային առաջադրանքը (տեխնիկական բնութագիրը) կազմում է",
        answers: [
            "Համայնքի ղեկավարը",
            "Կառուցապատողը",
            "Ճարտարապետը",
        ],
        correct: 1 // Question 57
    },
    {
        topic: "2.3.Նախագծային առաջադրանք, տեխնիկական բնութագիր,",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նախագծային առաջադրանքը (տեխնիկական բնութագիրը) կցվում է",
        answers: [
            "Նախագծային կապալի պայմանագրին",
            "Ճարտարապետահատակագծային առաջադրանքին",
            "Շինարարության թույլտվությանը",
        ],
        correct: 0 // Question 58
    },
    {
        topic: "2.3.Նախագծային առաջադրանք, տեխնիկական բնութագիր,",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նախագծային առաջադրանքում (տեխնիկական բնութագրում) չեն նշվում",
        answers: [
            "Կառուցապատման չափորոշիչները",
            "Տարբերակների մշակման պահանջները",
            "Ճարտարապետական լուծումներին ներկայացվող պահանջները",
        ],
        correct: 0 // Question 59
    },
    {
        topic: "2.4.Պատվիրատուի իրավունքները և պարտականությունները նախագծային աշխատանքների կապալի պայմանագրում",
        materials: "օգտագործված նյութեր ՔՕ, հոդվ.758, 2",
        question: "Կարող է արդյոք պատվիրատուն նախագծային փաստաթղթերը փոխանցել երրորդ անձանց",
        answers: [
            "Այո",
            "Ոչ, եթե կապալի պայմանագրով այլ բան չի նախատեսված",
            "Այո, կապալառուի համաձայնությամբ",
        ],
        correct: 1 // Question 60
    },
    {
        topic: "2.4.Պատվիրատուի իրավունքները և պարտականությունները նախագծային աշխատանքների կապալի",
        materials: "օգտագործված նյութեր ՔՕ, հոդվ. 758,2",
        question: "Կարող է արդյոք պատվիրատուն նախագծային փաստաթղթերում պարունակվող տվյալները հրապարակել առանց կապալառուի համաձայնության",
        answers: [
            "Այո",
            "Ոչ, եթե կապալի պայմանագրով այլ բան չի նախատեսված",
            "Ոչ",
        ],
        correct: 1 // Question 61
    },
    {
        topic: "2.5.Կապալառուի իրավունքները և պարտականությունները նախագծային աշխատանքների կապալի պայմանագրում",
        materials: "օգտագործված նյութեր ՔՕ, հոդվ. 759,1.2",
        question: "Պարտավոր է արդյոք կապալառուն պատվիրատուի հետ միասին մասնակցել նախագծային փաստաթղթերը իրավասու պետական և (կամ) տեղական ինքնակառավարման մարմինների հետ համաձայնեցնելու գործընթացին",
        answers: [
            "Այո",
            "Ոչ",
            "Այո, ըստ անհրաժեշտության",
        ],
        correct: 0 // Question 62
    },
    {
        topic: "2.5.Կապալառուի իրավունքները և պարտականությունները նախագծային աշխատանքների կապալի պայմանագրում",
        materials: "օգտագործված նյութեր ՔՕ, հոդվ. 759,1. 4",
        question: "Կարող է արդյոք կապալառուն առանց պատվիրատուի համաձայնության նախագծային փաստաթղթերը հանձնել երրորդ անձանց",
        answers: [
            "Այո",
            "Ոչ",
            "Այո, եթե նախատեսված է կապալի պայմանագրով",
        ],
        correct: 1 // Question 63
    },
    {
        topic: "2.5.Կապալառուի իրավունքները և պարտականությունները նախագծային աշխատանքների կապալի պայմանագրում",
        materials: "օգտագործված նյութեր ՔՕ, 760,2",
        question: "Պարտավոր է արդյոք կապալառուն հատուցել պատվիրատուին պատճառված վնասները նախագծային փաստաթղթերում թերություններ հայտնաբերվելու դեպքում",
        answers: [
            "Այո",
            "Ոչ",
            "Այո, եթե այլ բան նախատեսված չէ օրենքով կամ նախագծային աշխատանքների կապալի պայմանագրով",
        ],
        correct: 2 // Question 64
    },
    {
        topic: "2.6. Հեղինակային իրավունք",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ.6",
        question: "Օբյեկտի նախագծի գործնական իրականացման ընթացքում հեղինակային հսկողությունը պարտավոր է ապահովել",
        answers: [
            "Կառուցապատողը, եթե նախագծային աշխատանքների կապալի պայմանագրով այլ բան նախատեսված չէ",
            "Շինարարության թույլտվություն տվող իրավասու մարմինը",
            "Ճարտարապետը",
        ],
        correct: 0 // Question 65
    },
    {
        topic: "2.7. Ելակետային տվյալներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Կառուցապատմանն առնչվող ելակետային տվյալները ներառվում են",
        answers: [
            "Նախագծային աշխատանքների կապալի պայմանագրում",
            "Նախագծային առաջադրանքում",
            "Ճարտարապետահատակագծային առաջադրանքում",
        ],
        correct: 2 // Question 66
    },
    {
        topic: "2.7. Ելակետային տվյալներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ելակետային տվյալները (նախագծման տեխնիկական պայմանները) տրամադրում են",
        answers: [
            "Համայնքի ղեկավարը",
            "Մատակարար կազմակերպությունները",
            "Կառուցապատողները",
        ],
        correct: 1 // Question 67
    },
    {
        topic: "2.7. Ելակետային տվյալներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Մատակարար կազմակերպությունները նախագծման տեխնիկական պայմանները տրամադրում են",
        answers: [
            "Կառուցապատողին",
            "Կապալառուին",
            "Համայնքի ղեկավարին",
        ],
        correct: 2 // Question 68
    },
    {
        topic: "2.8. Շինարարության օբյեկտների դասակարգում",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Հայաստանի Հանրապետությունում շինարարության օբյեկտներն ըստ ռիսկայնության աստիճանի դասակարգվում են",
        answers: [
            "Չորս կատեգորիաների",
            "Հինգ կատեգորիաների",
            "Վեց կատեգորիաների",
        ],
        correct: 1 // Question 69
    },
    {
        topic: "2.9.Նախագծերի մշակման փուլային տարբերակներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Երկու փուլով մշակվում են",
        answers: [
            "2-րդ և 3-րդ կատեգորիայի օբյեկտների նախագծերը",
            "4-րդ և 5-րդ կատեգորիայի օբյեկտների նախագծերը",
            "Բոլոր օբյեկտների նախագծերը",
        ],
        correct: 1 // Question 70
    },
    {
        topic: "2.9.Նախագծերի մշակման փուլային տարբերակներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Նախագծային փաստաթղթերի՝ երկու փուլով մշակման դեպքում համաձայնեցվող փուլ է համարվում",
        answers: [
            "«Աշխատանքային փաստաթղթեր» փուլը",
            "«Նախագիծ» փուլը",
            "«Աշխատանքային նախագիծ» փուլը",
        ],
        correct: 1 // Question 71
    },
    {
        topic: "2.10.Բնակելի շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ 31-01-2014",
        question: "Հարմարավետության քանի մակարդակ ունեն բազմաբնակարան շեները",
        answers: [
            "Երկու մակարդակ",
            "Երեք մակարդակ",
            "Չորս մակարդակ",
        ],
        correct: 1 // Question 72
    },
    {
        topic: "2.10.Բնակելի շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ 31-01-2014",
        question: "Բնակելի շենքերում չի թույլատրվում տեղադրել",
        answers: [
            "Գրասենյակային տարածքներ",
            "Մսամթերքի խանութներ",
            "Ռենտգեն կաբինետներ",
            "Մանկապարտեզներ",
        ],
        correct: 2 // Question 73
    },
    {
        topic: "2.10.Բնակելի շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ 31-01-2014",
        question: "Բազմաբնակարան շենքերում բնակելի սենյակների, խոհանոցի (ճաշասենյակ-խոհանոցի) բարձրությունը (հատակից առաստաղ) պետք է լինի՝",
        answers: [
            "2.5 մ-ից ոչ պակաս",
            "2.7 մ-ից ոչ պակաս",
            "3.0 մ-ից ոչ պակաս",
        ],
        correct: 1 // Question 74
    },
    {
        topic: "2.11.Հասարակական շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ 31-03-2018 կետ 8",
        question: "Մանսարդային հարկի բարձրությունը տանիքի լանջի և շենքի ճակատի հատման մասում չպետք է գերազանցի",
        answers: [
            "1.5մ",
            "1.8մ",
            "2.1մ",
        ],
        correct: 0 // Question 75
    },
    {
        topic: "2.11.Հասարակական շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ 31-03-2018",
        question: "նկուղային հարկ՝ հարկ, որի հատակի նիշը ցածր է գետնի հատակագծային նիշից՝ մայթից կամ սալվածքից",
        answers: [
            "մնչև 1մ.",
            "հարկի բարձրության կեսից ավելի չափով",
            "հարկի բարձրության կեսից պակաս չափով",
        ],
        correct: 1 // Question 76
    },
    {
        topic: "2.11.Հասարակական շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ 31-03-2018",
        question: "Հասարակական շենքերում մարդկանց մշտական ներկայությամբ ամենահեռավոր սենքի դռներից մինչև մարդատար վերելակը պետք է լինի ոչ ավելի",
        answers: [
            "40 մետրից",
            "50 մետրից",
            "60 մետրից",
        ],
        correct: 2 // Question 77
    },
    {
        topic: "2.11.Հասարակական շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ 31-03-2018",
        question: "Հանդիսասրահներում նստաշարքերում անընդմեջ նստատեղերի քանակը մակողմանի ելքի դեպքում պետք է լինի ոչ ավելի",
        answers: [
            "15-ից",
            "25-ից",
            "20-ից",
        ],
        correct: 1 // Question 78
    },
    {
        topic: "2.11.Հասարակական շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ 31-03-2018",
        question: "Հանդիսատեսային դահլիճների տարողունակությունը",
        answers: [
            "նորմավորվոմ է ըստ շենքի հրակայոնոթյան դասի",
            "նորմավորվոմ է ըստ տեղադրման հարկի",
            "չի նորմավորվում",
        ],
        correct: 0 // Question 79
    },
    {
        topic: "2.12.Արտադրական շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ III-9.02.02-03, հավելված Ա",
        question: "Ի՞նչ է սանիտարական պահպանության գոտին",
        answers: [
            "Արտադրական օբյեկտներին կից տարածք, որտեղ արգելվում է տնտեսական գործունեությունը,",
            "Տարածք արդյունաբերական կազմակերպությունների և բնակելի գոտու միջև, որը նախանշված է վնասակար գործոններից բնակչության պահպանության համար.",
            "Առողջապահական օբյեկտներին կից ընդհանուր օգտագործման տարածք",
        ],
        correct: 1 // Question 80
    },
    {
        topic: "2.12.Արտադրական շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ III-9.02.02-03",
        question: "Մթնոլորտային օդի աղտոտման աղբյուր ունեցող կազմակերպությունները բնակելի կառուցապատման նկատմամբ պետք է տեղաբաշխվեն, հաշվի առնելով՝",
        answers: [
            "Ռելիեֆի առանձնահատկությունները",
            "Քամիների գերակշռող ուղղությունը",
            "Սանիտարական պահպանության գոտու լայնությունը",
        ],
        correct: 1 // Question 81
    },
    {
        topic: "2.12.Արտադրական շենքերի նախագծում",
        materials: "օգտագործված նյութեր ՀՀՇՆ IV-11.03.01-04",
        question: "Արտադրական շենքերում երդիկների երկարությունը պետք է լինի ոչ ավել",
        answers: [
            "60մ",
            "90մ",
            "120մ",
        ],
        correct: 2 // Question 82
    },
    {
        topic: "2.13.Փորձաքննության տեսակներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Ι և II կատեգորիաների ռիսկայնոթյան օբյեկտների նախագծային փաստաթղթերի համար պահանջվոմ է",
        answers: [
            "Պարզ փորձաքննություն",
            "Համալիր փորձաքննություն",
            "Փորձաքննություն չի պահանջվում",
        ],
        correct: 2 // Question 83
    },
    {
        topic: "2.13.Փորձաքննության տեսակներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Միջին ռիսկայնության աստիճանի (II կատեգորիայի) դասակարգում ունեցող օբյեկտների նախագծային փաստաթղթերի փորձաքննությունը կարող է փոխարինվել",
        answers: [
            "Կառուցապատողի գրավոր երաշխավորագրով",
            "Նախագիծը թողարկող աշխատանքների պատասխանատու կապալառուի գրավոր երաշխավորագրով",
            "Մասնագիտական եզրակացությամբ",
        ],
        correct: 1 // Question 84
    },
    {
        topic: "2.13.Փորձաքննության տեսակներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Միջինից բարձր ռիսկայնության աստիճանի(III կատեգորիայի) դասակարգում ունեցող օբյեկտների նախագծերի համար պահանջվում է",
        answers: [
            "Պարզ փորձաքննություն",
            "Պետական համալիր փորձաքննություն",
            "Հատուկ համալիր փորձաքննություն",
        ],
        correct: 0 // Question 85
    },
    {
        topic: "2.13.Փորձաքննության տեսակներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Բարձր ռիսկայնության աստիճանի (IV կատեգորիայի) դասակարգում ունեցող օբյեկտների նախագծերի համար պահանջվում է",
        answers: [
            "Պարզ փորձաքննություն",
            "Համալիր փորձաքննություն",
            "Հատուկ համալիր փորձաքննություն",
        ],
        correct: 1 // Question 86
    },
    {
        topic: "2.13.Փորձաքննության տեսակներ",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Բարձրագույն ռիսկայնության աստիճանի (V կատեգորիայի) դասակարգում ունեցող օբյեկտների նախագծերի համար պահանջվում է",
        answers: [
            "Պարզ փորձաքննություն",
            "Համալիր փորձաքննություն",
            "Հատուկ համալիր փորձաքննություն",
        ],
        correct: 2 // Question 87
    },
    {
        topic: "2.14.Նորմատիվ-տեխնիկական փաստաթղթերի համակարգ",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 16",
        question: "Քաղաքաշինական նորմատիվ-տեխնիկական փաստաթղթերը հիմք են ծառայում Ա. Փորձաքննության, քաղաքաշինական գործունեության վերահսկողության, վիճելի հարցերի լուծման համար",
        answers: [
            "Նախագծային աշխատանքների կապալի պայմանագրի համար",
            "Ճարտարապետահատակագծային առաջադրանքի տրամադրման համար",
            "Նախագծային առաջադրանք կազմելու համար ԳԼՈՒԽ 3․Քաղաքաշինական ծրագրային փաստաթղթերի մշակում",
        ],
        correct: 0 // Question 88
    },
    {
        topic: "3.1.Տարածական պլանավորման փաստաթղթերի համակարգ",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ.17,4",
        question: "Նշված նախագծերից ո՞րը չի հանդիսանում քաղաքաշինական ծրագրային փաստաթուղթ",
        answers: [
            "բնակավայրի գլխավոր հատակագիծ,",
            "կառուցապատման նախագիծ",
            "պատմության և մշակույթի անշարժ հուշարձանների պահպանության գոտիների նախագծեր,",
            "Բնության հատուկ պահպանվող տարածքների նախագծեր",
        ],
        correct: 1 // Question 89
    },
    {
        topic: "3.1.Տարածական պլանավորման փաստաթղթերի համակարգ",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 17,4",
        question: "Թվարկվածներից որն է հանդիսանում քաղաքաշինական ծրագրային փաստաթուղթ",
        answers: [
            "Կառուցապատման նախագիծը",
            "Բնակավայրերի պատմամշակութային հինավորվածների, պատմության և մշակույթի անշարժ հուշարձանների պահպանության գոտիների, բնության հատուկ պահպանվող տարածքների նախագծերը",
            "Շրջակա միջավայրի վրա ազդեցության գնահատման նախագիծը",
        ],
        correct: 1 // Question 90
    },
    {
        topic: "3.2. ՀՀ տարաբնակեցման գլխավոր նախագիծ",
        materials: "օգտագործված նյութեր ԿՈ, 19.12.2002, N 2164-Ն",
        question: "Քանի փուլով է մշակվում ՀՀ տարաբնակեցման գլխավոր նախագիծը",
        answers: [
            "Մեկ փուլով",
            "Երկու փուլով",
            "Երեք փուլով",
        ],
        correct: 1 // Question 91
    },
    {
        topic: "3.2. ՀՀ տարաբնակեցման գլխավոր նախագիծ",
        materials: "օգտագործված նյութեր ԿՈ, 19.12.2002, N 2164-Ն",
        question: "Նշվածներից որը չի հանդիսանում ՀՀ տարաբնակեցման գլխավոր նախագծի իրականացման ընթացքի մոնիտորինգային ուղղություն",
        answers: [
            "Տարածագոտիների զարգացման ռեժիներ",
            "Շրջակա միջավայրի պահպանության միջոցառումներ",
            "Բնակավայրերի զարգացման ռեժիներ",
            "Ինժեներատրանսպորտային ենթակառուցվածքներ",
        ],
        correct: 1 // Question 92
    },
    {
        topic: "3.2. ՀՀ տարաբնակեցման գլխավոր նախագիծ",
        materials: "օգտագործված նյութեր ԿՈ, 19.12.2002, N 2164-Ն",
        question: "Ինչ մասշտաբի քարտեզի վրա է մշակվ-մ ՀՀ տարաբնակեցման և տարածքի քաղաքաշինական կազմակերպման հեռանկարային կառուցվածքը",
        answers: [
            "1:100.000",
            "1:200.000",
            "1:500.000",
        ],
        correct: 1 // Question 93
    },
    {
        topic: "3.3.Մարզերի տարածքային հատակագծման նախագծեր",
        materials: "օգտագործված նյութեր ԿՈ, 08.08.2003, N 997-Ն,հավել.",
        question: "Նշվածներից որ կետը չի արտացոլվում տարածքային հատակագծման նախագծում",
        answers: [
            "Բնակավայրերի տարածքային զարգացման վերաբերյալ առաջարկություններ",
            "Բնակավայրերի հատակագծային կառուցվածք",
            "Արտադրատնտեսական օբյեկտների և նոր բնակավայրերի համար ընտրված տարածքային ռեսուրսներ",
            "Հանգստյան, առողջարարական գոտիների տեղաբաշխում",
        ],
        correct: 1 // Question 94
    },
    {
        topic: "3.3.Մարզերի տարածքային հատակագծման նախագծեր",
        materials: "օգտագործված նյութեր ԿՈ, 08.08.2003, N 997-Ն",
        question: "Որ մարմին է հաստատում տարածքային հատակագծման նախագիծը",
        answers: [
            "Քաղաքաշինության բնագավառի լիազոր մարմինը,",
            "Համապատասխան մարզպետը,",
            "ՀՀ կառավարությունը",
        ],
        correct: 2 // Question 95
    },
    {
        topic: "3.4.Համակցված տարածական պլանավորման փաստաթղթեր",
        materials: "օգտագործված նյութեր ԿՈ, 29.12.2011, N 1920-Ն, հավել.",
        question: "Նշվածներից որ կետը չի արտացոլվում համակցված տարածական պլանավորման փաստաթղթում",
        answers: [
            "Բնակավայրերի տարածքային զարգացման վերաբերյալ առաջարկությունները",
            "Արտադրատնտեսական օբյեկտների և նոր բնակավայրերի համար ընտրված տարածքային ռեսուրսները",
            "Արտադրական և կենցաղային թափոնների վնասազերծման, վերամշակման, պահեստավորման և թաղման օբյեկտների համար տարածքների ընտրությունը",
            "Տարածքների գոտիավորումն ըստ նպատակային նշանակության",
        ],
        correct: 3 // Question 96
    },
    {
        topic: "3.5.Համայնքի գլխավոր հատագիծ",
        materials: "օգտագործված նյութեր ՔՇՕ,հոդվ. 14.3",
        question: "Համայնքի գլխավոր հատակագծի նախագծման առաջադրանքը հաստատում է",
        answers: [
            "Քաղաքի գլխավոր ճարտարապետը",
            "Լիազոր մարմինը",
            "Համայնքի ավագանին",
            "Մարզպետը",
        ],
        correct: 2 // Question 97
    },
    {
        topic: "3.5.Համայնքի գլխավոր հատագիծ",
        materials: "օգտագործված նյութեր ԿՈ,29.12.2011, N1920-Ն",
        question: "Քանի՞ տարվա հեռանկարով է մշակվում համայնքի գլխավոր հատակագիծը",
        answers: [
            "5 տարի,",
            "10 տարի,",
            "15 տարի",
            "20 տարի",
        ],
        correct: 2 // Question 98
    },
    {
        topic: "3.5.Համայնքի գլխավոր հատագիծ",
        materials: "օգտագործված նյութեր ԿՈ,29.12.2011, N1920-Ն",
        question: "Նշվածներից ո՞րը բնակավայրի գլխավոր հատակագծի բաժին չէ",
        answers: [
            "տարածքի համալիր գնահատման հատակագիծ,",
            "ծավալատարածական գոտիավորումմ՝ ըստ կառուցապատման չափորոշիչների",
            "լանդշաֆտի կազմակերպման ուրվագիծ,",
            "տրանսպորտի ուրվագիծ",
        ],
        correct: 1 // Question 99
    },
    {
        topic: "3.5.Համայնքի գլխավոր հատագիծ",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ.14.3,2",
        question: "Համայնքի բնակավայրի գլխավոր հատակագիծը",
        answers: [
            "Ճարտարապետաշինարարական նախագծային փաստաթուղթ է",
            "Համայնքի զարգացման քառամյա ծրագրի մաս է",
            "Համայնքի տարածական զարգացման հիմնադրույթներն ամրագրող ռազմավարական բնույթի փաստաթուղթ է",
        ],
        correct: 2 // Question 100
    },
    {
        topic: "3.5.Համայնքի գլխավոր հատագիծ",
        materials: "օգտագործված նյութեր ԿՈ,29.12.2011, N1920-Ն",
        question: "Նշվածներից ո՞րը չի հանդիսանում համայնքի գլխավոր հատակագծի տեխնիկատնտեսական ցուցանիշ",
        answers: [
            "Տարածքը",
            "դեմոգրաֆիական տվյալները",
            "կառուցապատման խտությունը",
            "բնակֆոնդը",
        ],
        correct: 2 // Question 101
    },
    {
        topic: "3.6.Գոտիավորման նախագծեր",
        materials: "օգտագործված նյութեր ՔՇՕ, Հոդվ.14.2, ՀՕ, Հոդվ.6",
        question: "Թվարկված գոտիներից ո՞րն է հանդիսանում հիմնական (բազային)",
        answers: [
            "Արդյունաբերության, ընդերքօգտագործման և այլ արտադրական նշանակության",
            "բնակելի կառուցապատման",
            "ընդհանուր օգտագործման",
            "հասարակական կառուցապատման",
        ],
        correct: 0 // Question 102
    },
    {
        topic: "3.6.Գոտիավորման նախագծեր",
        materials: "օգտագործված նյութեր ՔՇՕ, Հոդվ.14.2",
        question: "Թվարկվածներից ո՞րը չի հանդիսանում կառուցապատման չափորոշիչ",
        answers: [
            "Կառուցապատման խտություն,",
            "Կառուցապատված և կանաչ մակերեսների հարաբերակցություն",
            "ճարտարապետական ոճ,",
            "Շենքերի և շինությունների բարձրություն",
        ],
        correct: 2 // Question 103
    },
    {
        topic: "3.6.Գոտիավորման նախագծեր",
        materials: "օգտագործված նյութեր ՔՇՕ, Հոդվ.14.2",
        question: "Նշվածներից ո՞րն է հանդիսանում օժանդակ գոտի",
        answers: [
            "հողամասի նպատակային նշանակություն",
            "Քաղաքաշինական սահմանափակների գոտի",
            "Բնապահպանական սահմանափակների գոտի",
            "Հողամասի գործառնական նշանակություն",
        ],
        correct: 3 // Question 104
    },
    {
        topic: "3.6.Գոտիավորման նախագծեր",
        materials: "օգտագործված նյութեր ՔՇՕ, Հոդվ.14.2",
        question: "Նշվածներից ո՞րն է հանդիսանում կառուցապատման չափորոշիչ",
        answers: [
            "Շենքերի փողոցահայաց ճակատներին ներկայացվող պահանջներ,",
            "Գովազդային վահանակներին ներկայացվող պահանջներ,",
            "Շենքերի և շինությունների բարձրություն",
            "Գործունեության առանձին տեսակների սահմանափակում",
        ],
        correct: 2 // Question 105
    },
    {
        topic: "3.6.Գոտիավորման նախագծեր",
        materials: "օգտագործված նյութեր ԿՈ, 14.05.2001, N408, հավել.",
        question: "Նշվածներից որը չի ընդգրկվում գոտևորման նախագծի «կառուցապատման կանոններ» բաժնում",
        answers: [
            "Աղմուկից, շրջակա միջավայրի աղտոտումից, վիբրացիայից, արտացոլումներից պաշտպանության միջոցառումներ",
            "Գոտևորման ընդունված սկզբունքներին չհամապատասխանող շենքերի և շինությունների աստիճանական վերափոխման միջոցառումների իրականացման մեխանիզմներ",
            "Կանաչապատ, ոչ կանաչապատ մակերևույթների համամասնությունները",
            "Տարածքներին, շենքերին, շինություններին, փողոցների ձևավորմանը, գովազդին, ցուցանակներին և այլ նշաններին ներկայացվող պահանջներ",
        ],
        correct: 2 // Question 106
    },
    {
        topic: "3.6.Գոտիավորման նախագծեր",
        materials: "օգտագործված նյութեր ԿՈ, 14.05.2001, N408, հավել.",
        question: "Թվարկվածներից որն է հանդիսանում կառուցապատման կանոն",
        answers: [
            "կառուցապատման տոկոսը.",
            "կառույցի հեռավորությունը հարևան հողամասից",
            "արհեստական լուսավորմանը ներկայացվող պահանջները",
            "Անջրանցիկ մակերեսների տոկոսը",
        ],
        correct: 2 // Question 107
    },
    {
        topic: "3.6.Գոտիավորման նախագծեր",
        materials: "օգտագործված նյութեր ՔՇՕ, Հոդվ. 14.1",
        question: "ճարտարապետահատակագծային առաջադրանքների տրամադրման համար հիմք է հանդիսանում",
        answers: [
            "Համայնքի հողօգտագործման սխեման",
            "Քաղաքաշինական գոտիավորման նախագիծը",
            "Համայնքի գլխավոր հատակագիծը",
        ],
        correct: 1 // Question 108
    },
    {
        topic: "3.7.Տարածական պլանավորման փաստաթղթերի մշակման, փորձաքննության, համաձայնեցումների և հաստատման ընթացակարգեր",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 10",
        question: "Քաղաքաշինական փաստաթղթերի մշակման և հաստատման կարգերը սահմանում է",
        answers: [
            "Ազգային ժողովը,",
            "ՀՀ կառավարությունը,",
            "Քաղաքաշինության կոմիտեն",
        ],
        correct: 1 // Question 109
    },
    {
        topic: "3.7.Տարածական պլանավորման փաստաթղթերի մշակման, փորձաքննության, համաձայնեցումների և հաստատման ընթացակարգեր",
        materials: "օգտագործված նյութեր ՔՇՕ, հոդվ. 14.4, 7",
        question: "Ո՞ր մարմինն է հաստատում համակցված տարածական պլանավորման փաստաթղթերը",
        answers: [
            "Քաղաքաշինության կոմիտեն",
            "Համապատասխան մարզպետը և մկրոռեգիոնալ մավորի մեջ ընդգրկված համայնքների ավագանիները",
            "Համայնքների ավագանիները",
            "ՀՀ կառավարությունը",
        ],
        correct: 1 // Question 110
    },
    {
        topic: "3.7.Տարածական պլանավորման փաստաթղթերի մշակման, փորձաքննության, համաձայնեցումների և հաստատման ընթացակարգեր",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "ինչպիսի՞ փորձաքննության են ենթակա տարածական պլանավորման փաստաթղթերը",
        answers: [
            "պարզ փորձաքննություն",
            "պետական համալիր փորձաքննություն,",
            "հատուկ համալիր փորձաքննություն",
        ],
        correct: 1 // Question 111
    },
    {
        topic: "3.7.Տարածական պլանավորման փաստաթղթերի մշակման, փորձաքննության, համաձայնեցումների և հաստատման ընթացակարգեր",
        materials: "օգտագործված նյութեր ՔՇՕ,հոդվ. 14.3,",
        question: "Ո՞ր մարմինն է հաստատում բնակավայրի գլխավոր հատակագիծը",
        answers: [
            "Քաղաքաշինության կոմիտեն,",
            "Համայնքի ղեկավարը,",
            "Համայնքի ավագանին",
            "Մարզպետը",
        ],
        correct: 2 // Question 112
    },
    {
        topic: "3.7.Տարածական պլանավորման փաստաթղթերի մշակման, փորձաքննության, համաձայնեցումների և հաստատման ընթացակարգեր",
        materials: "օգտագործված նյութեր ԿՈ, 19.03.2015, N596-Ն",
        question: "Տարածական պլանավորման փաստաթղթերը ենթակա են",
        answers: [
            "Պարզ փորձաքննության,",
            "Հատուկ համալիր փորձաքննությն,",
            "Պետական համալիր փորձաքննության",
        ],
        correct: 2 // Question 113
    },
    {
        topic: "3.8.Բնակավայրերի հատակագծման և կառուցապատման նորմեր",
        materials: "օգտագործված նյութեր ՀՀՇՆ 30-01-2014, աղ.6",
        question: "Որքա՞ն է կառուցապատման առավելագույն տոկոսը հասարակական բազմագործառույթ կառուցապատման գոտում",
        answers: [
            "50 տոկոս,",
            "70 տոկոս,",
            "100 տոկոս",
        ],
        correct: 2 // Question 114
    },
    {
        topic: "3.8.Բնակավայրերի հատակագծման և կառուցապատման նորմեր",
        materials: "օգտագործված նյութեր ՀՀՇՆ 30-01-2014, աղ.6",
        question: "Որքա՞ն է կառուցապատման առավելագույն տոկոսը միջին հարկայնության/բազմաբնակարան կառուցապատման գոտում",
        answers: [
            "20 տոկոս,",
            "30 տոկոս,",
            "40 տոկոս",
        ],
        correct: 2 // Question 115
    },
    {
        topic: "3.8.Բնակավայրերի հատակագծման և կառուցապատման նորմեր",
        materials: "օգտագործված նյութեր ՀՀՇՆ 30-01-2014, աղ.6",
        question: "Որքա՞ն է կառուցապատման խտության առավելագույն գործակիցը",
        answers: [
            "1.2",
            "2.4",
            "3.0",
            "4.5",
        ],
        correct: 2 // Question 116
    },
    {
        topic: "3.8.Բնակավայրերի հատակագծման և կառուցապատման նորմեր",
        materials: "օգտագործված նյութեր ՀՀՇՆ 30-01-2014, աղ.6",
        question: "Որքա՞ն պետք է լինի կառուցապատման առավելագույն տոկոսը կանաչապոտ տարածքներում",
        answers: [
            "5 տոկոս,",
            "7 տոկոս",
            "10 տոկոս",
        ],
        correct: 1 // Question 117
    },
    {
        topic: "3.8.Բնակավայրերի հատակագծման և կառուցապատման նորմեր",
        materials: "օգտագործված նյութեր ՀՀՇՆ 30-01-2014",
        question: "Որքան է հասանելիության առավելագույն ժամանակը տարրական դասարանների համար",
        answers: [
            "10-15 րոպե",
            "15-25 րոպե,",
            "25-30 րոպե",
        ],
        correct: 0 // Question 118
    },
    {
        topic: "3.8.Բնակավայրերի հատակագծման և կառուցապատման նորմեր",
        materials: "օգտագործված նյութեր ՀՀՇՆ 30-01-2014",
        question: "Որքան է հասանելիության առավելագույն ժամանակը միջին դասարանների համար",
        answers: [
            "20 րոպե",
            "30 րոպե",
            "45 րոպե",
        ],
        correct: 1 // Question 119
    },
    {
        topic: "3.8.Բնակավայրերի հատակագծման և կառուցապատման նորմեր",
        materials: "օգտագործված նյութեր ՀՀՇՆ 30-01-2014",
        question: "Որքան է հասանելիության առավելագույն ժամանակը ավագ դասարանների համար",
        answers: [
            "30 րոպե",
            "45րոպե",
            "1 ժամ ԳԼՈՒԽ 4․Պատմաճարտարապետական հուշարձանների ամրակայում, նորոգում և վերականգնում",
        ],
        correct: 1 // Question 120
    },
    {
        topic: "4.Հուշարձանների դասակարգում ըստ նշանակության և բնույթի",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 1",
        question: "Հուշարձաններն ըստ արժեվորման չափանիշների դասակարգվում են",
        answers: [
            "Հանրապետական և տեղական նշանակության",
            "Հանրապետական և համայնքային նշանակության",
            "մարզային և տեղական նշանակության",
        ],
        correct: 0 // Question 121
    },
    {
        topic: "4.Հուշարձանների դասակարգում ըստ նշանակության և բնույթի",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 6",
        question: "Ում կողմից է կատարվում հուշարձանների դասակարգումը",
        answers: [
            "ՀՀ կառավարությունը՝ գիտամեթոդական խորհրդի եզրակացության հիման վրա",
            "Լիազորված պետական կառավարման մարմինը՝ փորձագիտական հանձնաժողովի եզրակացության հիման վրա",
            "ՀՀ տարածքային կառավարման մարմինը՝ փորձագիտական հանձնաժողովի եզրակացության հիման վրա",
        ],
        correct: 1 // Question 122
    },
    {
        topic: "4.Հուշարձանների դասակարգում ըստ նշանակության և բնույթի",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 6",
        question: "Ըստ բնույթի հուշարձանները դասակարգվում են",
        answers: [
            "Հնագիտական, պատմական, քաղաքաշինական և ճարտարապետական, մոն,մենտալ արվեստի",
            "Հնագիտական, քաղաքաշինական և ճարտարապետական, ճարտարապետական փոքր ձևի",
            "Հնագիտական, պատմական, քաղաքաշինական և ազգագրական",
        ],
        correct: 0 // Question 123
    },
    {
        topic: "4.2.Պետական և տեղական ինքնակառավարման մարմինների իրավասությունները հուշարձանների պահպանության և օգտագործման բնագավառում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 6",
        question: "Ում պահպանության ներքո են գտնվում Հայաստանի հանրապետության տարածքում գտնվող պատմության և մշակույթի անշարժ հուշարձանները",
        answers: [
            "հուշարձանների պահպանության լիազոր մարմնի",
            "տեղական ինքնակառավարման մարմինների",
            "պետության",
        ],
        correct: 2 // Question 124
    },
    {
        topic: "4.2.Պետական և տեղական ինքնակառավարման մարմինների իրավասությունները հուշարձանների պահպանության և օգտագործման բնագավառում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 8.ա",
        question: "Որ մարմինն է ապահովում հուշարձանների պահպանության և օգտագործման բնագավառում պետական քաղաքականության իրականացումը",
        answers: [
            "ՀՀ կառավարության լիազորած պետական կառավարման մարմինը",
            "ՀՀ կառավարությունը",
            "ՀՀ տարածքային կառավարման մարնինները",
        ],
        correct: 1 // Question 125
    },
    {
        topic: "4.2.Պետական և տեղական ինքնակառավարման մարմինների իրավասությունները հուշարձանների պահպանության և օգտագործման բնագավառում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 8.դ",
        question: "Որ մարմինն է հաստատում անշարժ հուշարձանների պետական ցուցակները",
        answers: [
            "ՀՀ ազգային ժողովը",
            "ՀՀ կառավարության լիազորած պետական կառավարման մարմինը",
            "ՀՀ կառավարությունը",
        ],
        correct: 2 // Question 126
    },
    {
        topic: "4.2.Պետական և տեղական ինքնակառավարման մարմինների իրավասությունները հուշարձանների պահպանության և օգտագործման բնագավառում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 8.ե",
        question: "Որ մարմինն է ստեղծում պատմամշակութային և բնապատմական արգելոցներ",
        answers: [
            "ՀՀ կառավարության լիազորած պետական կառավարման մարմինը",
            "ՀՀ կառավարությունը",
            "ՀՀ կառավարության լիազորած բնապահպանության պետական կառավարման մարմինը",
        ],
        correct: 1 // Question 127
    },
    {
        topic: "4.2.Պետական և տեղական ինքնակառավարման մարմինների իրավասությունները հուշարձանների պահպանության և օգտագործման բնագավառում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 8.է",
        question: "Որ մարմինն է թույլտվություն տալիս հանրապետական նշանակության հուշարձանները տեղափոխելու և փոփոխելու համար",
        answers: [
            "ՀՀ ազգային ժողովը",
            "ՀՀ կառավարության լիազորած պետական կառավարման մարմինը",
            "ՀՀ կառավարությունը",
        ],
        correct: 2 // Question 128
    },
    {
        topic: "4.2.Պետական և տեղական ինքնակառավարման մարմինների իրավասությունները հուշարձանների պահպանության և օգտագործման բնագավառում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 9.գ",
        question: "Որ մարմինն է պետական վերահսկողություն ապահովում հուշարձանների պահպանության և օգտագործման մասին Հայաստանի Հանրապետության օրենսդրության պահանջների կատարման նկատմամբ",
        answers: [
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "ՀՀ կառավարությունը",
            "պետական կառավարման տարածքային մարմինները",
        ],
        correct: 0 // Question 129
    },
    {
        topic: "4.2.Պետական և տեղական ինքնակառավարման մարմինների իրավասությունները հուշարձանների պահպանության և օգտագործման բնագավառում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 9.ը",
        question: "Որ մարմինն է վարում հուշարձանների պետական հաշվառումը (կադաստրը)",
        answers: [
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "ՀՀ կառավարությունը",
            "ՀՀ անշարժ գույքի կադաստրի կոմիտե",
        ],
        correct: 0 // Question 130
    },
    {
        topic: "4.2.Պետական և տեղական ինքնակառավարման մարմինների իրավասությունները հուշարձանների պահպանության և օգտագործման բնագավառում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 9.ժա",
        question: "Որ մարմինն է հուշարձանների վերականգնման և բարեկարգման նախագծերի իրականացման ընթացքում վերահսկում հուշարձանների անվտանգության ապահովումը",
        answers: [
            "պետական կառավարման տարածքային մարմինները",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "ՀՀ քաղաքաշինության կոմիտեն ՊՀՊՕ, հոդվ. 9.ժա",
        ],
        correct: 1 // Question 131
    },
    {
        topic: "4.3.Հուշարձանների հաշվառումը և պետական ցուցակները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 12",
        question: "Որ մարմինն է իրականացնում հուշարձանների պետական հաշվառումը",
        answers: [
            "Պետական կառավարման տարածքային մարմինները",
            "ՀՀ տարածքային կառավարման և ենթակառուցվածքների նախարարությունը",
            "Հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
        ],
        correct: 2 // Question 132
    },
    {
        topic: "4.3.Հուշարձանների հաշվառումը և պետական ցուցակները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 12",
        question: "Ինչ ժամկետով են պահվում հուշարձանների պետական հաշվառման փաստաթղթերը",
        answers: [
            "25 տարի",
            "50տարի",
            "Անժամկետ",
        ],
        correct: 2 // Question 133
    },
    {
        topic: "4.3.Հուշարձանների հաշվառումը և պետական ցուցակները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 13",
        question: "Ինչն է հանդիսանում հիմնական փաստաթուղթը և իրավական հիմքը, օբյեկտին հուշարձանի կարգավիճակ տալու և պետության կողմից պահպանության վերցնելու համար",
        answers: [
            "Հուշարձանների պետական ցուցակները",
            "Փորձագիտական հանձնաժողովի դրական եզրակացությունը",
            "Գիտությունների ազգային ակադեմիայի դրական եզրակացությունը",
        ],
        correct: 0 // Question 134
    },
    {
        topic: "4.3.Հուշարձանների հաշվառումը և պետական ցուցակները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 14",
        question: "Ինչի հիման վրա է կատարվում հուշարձանների պետական ցուցակներում նոր օբյեկտ ընդգրկելը և այդ ցուցակից հանելը",
        answers: [
            "ՀՀ Գիտությունների ազգային ակադեմիայի եզրակացության հիման վրա",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմնի եզրակացության հիման վրա",
            "Փորձագիտական եզրակացության հիման վրա",
        ],
        correct: 2 // Question 135
    },
    {
        topic: "4.4.Հուշարձանների պահպանական գոտիները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 9,թ",
        question: "Որ մարմինն է կազմում և հաստատում հուշարձանների պահպանական գոտիների նախագծերը",
        answers: [
            "ՀՀ քաղաքաշինության կոմիտեն",
            "պետական կառավարման տարածքային մարմինները",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
        ],
        correct: 2 // Question 136
    },
    {
        topic: "4.4.Հուշարձանների պահպանական գոտիները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 16",
        question: "Հուշարձանների պահպանական գոտիների համակարգը կարող է ներառել",
        answers: [
            "հուշարձանի պահպանության գոտին, կառուցապատման կարգավորման գոտին, լանդշաֆտի պահպանման գոտին",
            "հուշարձանի տարածքը, հուշարձանի պահպանության գոտին, կառուցապատման կարգավորման գոտին",
            "հուշարձանի պահպանության գոտին, կառուցապատման կարգավորման գոտին, պոտենցիալ պեղման գոտին",
        ],
        correct: 0 // Question 137
    },
    {
        topic: "4.4.Հուշարձանների պահպանական գոտիները",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Հուշարձանների պահպանական գոտիների նախագիծը հաստատում է",
        answers: [
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "Հայաստանի Հանրապետության կառավարությունը",
            "պետական կառավարման տարածքային մարմինները",
        ],
        correct: 0 // Question 138
    },
    {
        topic: "4.4.Հուշարձանների պահպանական գոտիները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 16",
        question: "Հուշարձանների պահպանական գոտիների տարածքը դասվում է",
        answers: [
            "քաղաքաշինական սահմանափակումների գոտու կատեգորիային",
            "բնապահպանական սահմանափակուների գոտու կատեգորիային",
            "Պատմամշակութային նշանակության հողերի կատեգորիային",
        ],
        correct: 2 // Question 139
    },
    {
        topic: "4.4.Հուշարձանների պահպանական գոտիները",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Պահպանական գոտիների պայմանակարգը սահմանում է",
        answers: [
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "պետական կառավարման տարածքային մարմինները",
            "փորձագիտական հանձնաժողովը",
        ],
        correct: 0 // Question 140
    },
    {
        topic: "4.5.Պատմամշակութային արգելոցները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 9,ժ",
        question: "Որ մարմինն է առաջարկություն ներկայացնում ՀՀ կառավարություն՝ պատմամշակութային արգելոց ստեղծելու վերաբերյալ",
        answers: [
            "պետական կառավարման տարածքային մարմինները",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "տեղական ինքնակառավարման մարմինները",
        ],
        correct: 1 // Question 141
    },
    {
        topic: "4.5.Պատմամշակութային արգելոցները",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 17",
        question: "Պատմամշակութային արգելոցի տարածքի հողօգտագործումը կարող է թույլատրվել",
        answers: [
            "ՀՀ կառավարության որոշմամբ",
            "ՀՀ օրենսդրությամբ սահմանված կարգով",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմնի որոշմամբ",
        ],
        correct: 1 // Question 142
    },
    {
        topic: "4.6.Բնակավայրի պատմամշակութային հիմնավորման նախագծեր",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 11,ա",
        question: "Որ մարմինն է սահմանված կարգով ապահովում բնակավայրի պատմամշակութային հիմնավորման նախագծի կազմումը",
        answers: [
            "ՀՀ քաղաքաշինության կոմիտեն",
            "պետական կառավարման տարածքային մարմինները",
            "Տեղական ինքնակառավարման մարմինները",
        ],
        correct: 2 // Question 143
    },
    {
        topic: "4.6.Բնակավայրի պատմամշակութային հիմնավորման նախագծեր",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Պատմամշակութային հիմնավորման և հուշարձանների պահպանական գոտիների նախագծերը",
        answers: [
            "Քաղաքաշինական ծրագրային փաստաթղթեր են",
            "նախագծանախահաշվային փաստաթղթեր են",
            "ենթաօրենսդրական ակտեր են",
        ],
        correct: 0 // Question 144
    },
    {
        topic: "4.6.Բնակավայրի պատմամշակութային հիմնավորման նախագծեր",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 19",
        question: "Բնակավայրերի պատմամշակութային հիմնավորման նախագծերի առաջադրանքները կազմում է",
        answers: [
            "ՀՀ քաղաքաշինության կոմիտեն",
            "պետական կառավարման տարածքային մարմինները",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
        ],
        correct: 2 // Question 145
    },
    {
        topic: "4.7.Հուշարձանների հետախուզում և հնագիտական պեղումներ",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 9,ժբ",
        question: "Որ մարմինն է թույլտվություն տալիս հուշարձանների հետախուզման և պեղման աշխատանքների համար",
        answers: [
            "ՀՀ գիտությունների ազգային ակադեմիան",
            "ՀՀ ԳԱԱ Հնագիտության և ազգագրության ինստիտուտը",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
        ],
        correct: 2 // Question 146
    },
    {
        topic: "4.7.Հուշարձանների հետախուզում և հնագիտական պեղումներ",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Հուշարձանի զբաղեցրած տարածքում կարող են կատարվել",
        answers: [
            "գյուղատնտեսական աշխատանքներ և տնտեսական գործունեություն",
            "զբոսաշրջային ենթակառուցվածքային շինությունների կառուցում",
            "Հուշարձանի նպատակային օգտագործմանը նպաստող վերականգնողական և նորոգման աշխատանքներ",
        ],
        correct: 2 // Question 147
    },
    {
        topic: "4.7.Հուշարձանների հետախուզում և հնագիտական պեղումներ",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 25",
        question: "Որ մարմնի եզրակացության հիման վրա է տրվում ՀՀ տարածքում հուշարձանների հետախուզում և հնագիտական պեղումներ կատարելու թույլտվությունը",
        answers: [
            "միջգերատեսչական հնագիտական հանձնաժողովի դրական եզրակացության",
            "ՀՀ Գիտությունների ազգային ակադեմիայի դրական եզրակացության հիման վրա",
            "Փորձագիտական հանձնաժողովի դրական եզրակացության հիման վրա",
        ],
        correct: 0 // Question 148
    },
    {
        topic: "4.7.Հուշարձանների հետախուզում և հնագիտական պեղումներ",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 27",
        question: "Հետախուզում և հնագիտական պեղումներ ձեռնարկող կարող են լինել",
        answers: [
            "Հայաստանի Հանրապետության և այլ պետությունների իրավաբանական և ֆիզիկական անձինք",
            "միայն Հայաստանի Հանրապետության իրավաբանական անձինք",
            "միջգերատեսչական հնագիտական հանձնաժողովը",
        ],
        correct: 0 // Question 149
    },
    {
        topic: "4.7.Հուշարձանների հետախուզում և հնագիտական պեղումներ",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Հուշարձանների հետախուզման և հնագիտական պեղումների թույլտվության իրավազորությունը սահմանվում է",
        answers: [
            "անժամկետ",
            "մնչև ընթացիկ տարվա վերջը",
            "Մեկ օրացույցային տարի",
        ],
        correct: 2 // Question 150
    },
    {
        topic: "4.7.Հուշարձանների հետախուզում և հնագիտական պեղումներ",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 26",
        question: "Միջգերատեսչական հնագիտական հանձնաժողովի կազմը և կանոնադրությունը հաստատում է",
        answers: [
            "ՀՀ Գիտությունների ազգային ակադեմիայի նախագահությունը՝ հնագիտության և ազգագրության ինստիտուտի ներկայացմամբ",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը հնագիտության և ազգագրության ինստիտուտի ներկայացմամբ",
            "ՀՀ կառավարությունը՝ լիազորված մարմնի ներկայացմամբ",
        ],
        correct: 2 // Question 151
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 11,գ",
        question: "Որ մարմինն է սահմանված կարգով կազմակերպում տեղական նշանակության հուշարձանների ամրակայման, նորոգման, վերականգնման և տարածքի բարեկարգման աշխատանքները",
        answers: [
            "պետական կառավարման տարածքային մարմինները",
            "Տեղական ինքնակառավարման մարմինները",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
        ],
        correct: 1 // Question 152
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 30",
        question: "Որն է հուշարձանների ամրակայման նպատակը",
        answers: [
            "դրանց տեխնիկական վիճակի պահպանումը - բարելավումն է՝ առանց հուշարձանի տեսքի փոփոխության",
            "Տեխնիկական տարբեր միջոցներով, դրանց հետագա քայքայման կամ ավերման կանխումն է",
            "սկզբնական ձևավորված կերպարի մասնակի վերականգնումը",
        ],
        correct: 1 // Question 153
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 30",
        question: "Հուշարձանի նորոգման նպատակը",
        answers: [
            "տեխնիկական տարբեր միջոցներով, դրանց հետագա քայքայման կամ ավերման կանխումն է",
            "սկզբնական ձևավորված կերպարի մասնակի կամ լրիվ վերականգնումը",
            "Դրանց տեխնիկական վիճակի պահպանումը - բարելավումն է՝ առանց հուշարձանի տեսքի փոփոխության",
        ],
        correct: 2 // Question 154
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 30",
        question: "Հուշարձանների նորոգում է համարվում",
        answers: [
            "սկզբնական ձևավորված կերպարի մասնակի կամ լրիվ վերականգնումը",
            "Հուշարձանների հարմարեցումը (ադապտացիա)",
            "տեխնիկական տարբեր միջոցներով, դրանց հետագա քայքայման կամ ավերման կանխումը",
        ],
        correct: 1 // Question 155
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 30",
        question: "Հուշարձանների վերականգնման հիմնական նպատակը",
        answers: [
            "Հուշարձանների սկզբնական կամ պատմականորեն ձևավորված կերպարի մասնակի կամ լրիվ ամբողջացումն է",
            "տեխնիկական տարբեր միջոցներով, դրանց հետագա քայքայման կամ ավերման կանխումն է",
            "Հուշարձանների սկզբնական կերպարի գիտականորեն հիմնավորված վերստեղծումն է",
        ],
        correct: 0 // Question 156
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 30",
        question: "Հուշարձանների ամրակայման, նորոգման և վերականգնման աշխատանքների նախագծային առաջադրանքները և նախագծերը համաձայնեցվում են",
        answers: [
            "պատվիրատուի հետ",
            "պետական կառավարման տարածքային մարմինների հետ",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմնի հետ",
        ],
        correct: 2 // Question 157
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 33",
        question: "Հուշարձանների ամրակայման, նորոգման և վերականգնման աշխատանքները դադարեցնելու իրավունք ունեն",
        answers: [
            "Լիազորված պետական մարմինը և պետական կառավարման տարածքային մարմինը՝ տեղեկացնելով լիազորված մարմնին",
            "տեղական ինքնակառավարման մարմինները՝ տեղյակ պահելով լիազորված մարմնին",
            "լիազորված մարմինը՝ տեղյակ պահելով պետական կառավարման տարածքային մարմիններին",
        ],
        correct: 0 // Question 158
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Հուշարձանների ամրակայման, նորոգման, և վերականգնման գիտանախագծային աշխատանքներ կատարող կազմակերպությունները - մասնագետները (ՆԳՃ, հեղինակ) նախագծերի իրականացման ամբողջ ընթացքում կատարում են նաև",
        answers: [
            "Գիտական ղեկավարում և հեղինակային հսկողություն",
            "հեղինակային հսկողություն",
            "շինարարության ղեկավարում և հեղինակային հսկողություն",
        ],
        correct: 0 // Question 159
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Հուշարձանների ամրակայման, նորոգման, և վերականգնման գիտանախագծային փաստաթղթերի կազմումը՝ որպես կանոն, իրականացվում է",
        answers: [
            "1 փուլով՝ նախագծային փաստաթղթերի մշակում",
            "2 փուլով՝ էսքիզային նախագիծ, աշխատանքային գծագրեր",
            "1 փուլով՝ էսքիզային գծագրերի մշակման փուլ",
        ],
        correct: 1 // Question 160
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Հուշարձանների ամրակայման, նորոգման, և վերականգնման աշխատանքների ավարտից և ընդունումից հետո նախագծի հեղինակը աշխատանքի մասին գիտական հաշվետվությունը ինչ ժամկետում է պարտավոր կազմել և ներկայացնել",
        answers: [
            "Երեք ամսվա ընթացքում՝ լիազորված պետական մարմնին",
            "երեք ամսվա ընթացքում՝ պատվիրատուին",
            "վեց ամսվա ընթացքում՝ լիազորված մարմնին",
        ],
        correct: 0 // Question 161
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 21",
        question: "Հուշարձանների տեղափոխման և փոփոխման թույլտվությունը տրվում է միայն",
        answers: [
            "փորձագիտական եզրակացության հիման վրա",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմնի եզրակացության հիման վրա",
            "գիտամեթոդական խորհրդի եզրակացության հիման վրա",
        ],
        correct: 1 // Question 162
    },
    {
        topic: "4.8.Հուշարձանների ամրակայում, նորոգում և վերականգնում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 21",
        question: "Տեղական նշանակության հուշարձանների փոփոխումը կարող են կատարվել",
        answers: [
            "Պետական կառավարման տարածքային մարմինների թույլտվությամբ",
            "Փորձագիտական եզրակաց,թյան հիման վրա",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմնի թույլտվությամբ",
        ],
        correct: 0 // Question 163
    },
    {
        topic: "4.9.Հուշարձանի նկատմամբ սեփականության իրավունքը",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 11,զ",
        question: "Որ մարմինը կարող է լիազորված մարմնի համաձայնությամբ օգտագործման կամ վարձակալության հանձնել համայնքի սեփականություն համարվող հուշարձան շենքերը և շինությունները",
        answers: [
            "ՀՀ տարածքային կառավարման և ենթակառուցվածքների նախարարությունը",
            "Պետական կառավարման տարածքային մարմինները",
            "Տեղական ինքնակառավարման մարմինները",
        ],
        correct: 2 // Question 164
    },
    {
        topic: "4.9.Հուշարձանի նկատմամբ սեփականության իրավունքը",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 12",
        question: "Հայաստանի հանրապետության տարածքում գտնվող որ հուշարձաններն են ենթակա պետական հաշվառման՝ ըստ սեփականության ձևի",
        answers: [
            "պետական սեփականություն համարվող հուշարձանները",
            "ֆիզիկական անձանց պատկանող հուշարձանները",
            "Բոլոր հուշարձանները՝ անկախ սեփականությունան ձևից",
        ],
        correct: 2 // Question 165
    },
    {
        topic: "4.9.Հուշարձանի նկատմամբ սեփականության իրավունքը",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Հուշարձանի օտարման ժամանակ հուշարձանը գնելու (ձեռք բերելու) նախապատվության իրավունք ունի",
        answers: [
            "ՀՀ կառավարությունը",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "տեղական ինքնակառավարման մարմինները",
        ],
        correct: 1 // Question 166
    },
    {
        topic: "4.10.Հուշարձանների պահպանություն և օգտագործում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 10",
        question: "ՀՀ Մարզերի տարածքում ով է ապահովում վերահսկողություն հուշարձանների պահպանության և օգտագործման մասին ՀՀ օրենսդրության պահանջների կատարման նկատմամբ",
        answers: [
            "Պետական կառավարման տարածքային մարմինները",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "տեղական ինքնակառավարման մարմինները",
        ],
        correct: 0 // Question 167
    },
    {
        topic: "4.10.Հուշարձանների պահպանություն և օգտագործում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 11",
        question: "Որ մարմինն է ապահովում համայնքի տարածքում գտնվող հուշարձանների պահպանական գոտիներում սահմանված հատուկ ռեժիմ պահանջների կատարումը",
        answers: [
            "Պետական կառավարման տարածքային մարմինները",
            "Տեղական ինքնակառավարման մարմինները",
            "Հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
        ],
        correct: 1 // Question 168
    },
    {
        topic: "4.10.Հուշարձանների պահպանություն և օգտագործում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 18",
        question: "Բնության հատուկ պահպանվող տարածքներում գտնվող հուշարձանների պահպանությունը ապահովում են",
        answers: [
            "Այդ տարածքը տնօրինող պետական մարմինները",
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "ՀՀ շրջակա միջավայրի նախարարությունը",
        ],
        correct: 0 // Question 169
    },
    {
        topic: "4.10.Հուշարձանների պահպանություն և օգտագործում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 18",
        question: "Բնության հատուկ պահպանվող տարածքների սահմաններում գտնվող հուշարձաններին և դրանց բնապատմական միջավայրին առնչվող բոլոր աշխատանքները համաձայնեցվում են",
        answers: [
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմնի հետ",
            "Համապատասխան համայնքի ավագանու հետ",
            "պետական կառավարման տարածքային մարմինների հետ",
        ],
        correct: 0 // Question 170
    },
    {
        topic: "4.10.Հուշարձանների պահպանություն և օգտագործում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 38",
        question: "Հուշարձանների օգտագործման նպատակը, բնույթը, դրանց փոփոխությունները համաձայնեցվում են",
        answers: [
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմնի հետ",
            "հուշարձանների սեփականատերերի հետ",
            "Պետական կառավարման տարածքային մարմինների հետ",
        ],
        correct: 0 // Question 171
    },
    {
        topic: "4.10.Հուշարձանների պահպանություն և օգտագործում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 40",
        question: "Հուշարձանի օգտագործման իրավունքը կարող է նաև դադարեցվել",
        answers: [
            "Եթե երեք տարվա ընթացքում հուշարձանը չի օգտագործվել համապատասխան պայմանագրով նշված նպատակով",
            "եթե հինգ տարվա ընթացքում հուշարձանը չի օգտագործվել համապատասխան պայմանագրով նշված նպատակով",
            "եթե պայմանագիրը կնքելուց անմիջապես հետո հուշարձանը չի օգտագործվում համապատասխան պայմանագրով նշված նպատակով",
        ],
        correct: 0 // Question 172
    },
    {
        topic: "4.10.Հուշարձանների պահպանություն և օգտագործում",
        materials: "օգտագործված նյութեր ԿՈ, 20.04.2002, N438",
        question: "Հուշարձանի, դրա պահպանական գոտու օգտագործումը վաղաժամկետ դադարեցվում է",
        answers: [
            "հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմնի կողմից",
            "հուշարձանների պահպանության օրենքով սահմանված կարգով",
            "ՀՀ օրենսդրությամբ սահմանված կարգով",
        ],
        correct: 2 // Question 173
    },
    {
        topic: "4.10.Հուշարձանների պահպանություն և օգտագործում",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ. 41",
        question: "Զբոսաշրջության նպատակներով հուշարձանների օգտագործման կարգը և պայմանները սահմանում է",
        answers: [
            "Հուշարձանների պահպանության և օգտագործման բնագավառում լիազորված մարմինը",
            "Պետական կառավարման տարածքային մարմինները",
            "ՀՀ կառավարությունը",
        ],
        correct: 2 // Question 174
    },
    {
        topic: "4.11.Հուշարձանների պահպանության միջազգային պայմանագրեր",
        materials: "օգտագործված նյութեր ՊՀՊՕ, հոդվ.46",
        question: "Եթե ՀՀ միջազգային պայմանագրով սահմանված են այլ նորմեր, քան նախատեսված է ՀՀ Պատմության և մշակույթի անշարժ հուշարձանների ու պատմական միջավայրի պահպանության և օգտագործման մասին օրենքով (այսուհետ հուշարձանների պահպանության օրենք), ապա կիրառվում են",
        answers: [
            "ՀՀ հուշարձանների պահպանության օրենքը",
            "Միջազգային պայմանագրի նորմերը",
            "Հայաստանի Հանրապետության օրենսդրությամբ սահմանված կարգերը",
        ],
        correct: 1 // Question 175
    }
];
let currentQuestionIndex = 0;
let score = 0;
let userAnswers = [];
let gameStarted = false;
let userName = '';
let shuffledQuizData = []; // Shuffled version of quizData
let savedShuffledQuizData = []; // Saved shuffled data for repeat

// Quiz sets: 17 sets of 10 questions + 1 set of 5 questions (18th test) = 175 questions
let quizSets = []; // Array of quiz sets, each containing 10 or 5 questions
let currentQuizSetIndex = 0; // Current quiz set (0-17)
let quizSetResults = []; // Results for each quiz set: [{correct: X, wrong: Y}, ...]
let quizSetAttempts = {}; // Track attempts per quiz set: {1: 2, 3: 3, ...} (quiz set number: attempts count)
let userData = {
    name: '',
    score: 0,
    totalQuestions: 0,
    percentage: 0,
    deviceInfo: {},
    location: {},
    timestamp: '',
    answers: []
};

// Shuffle array function (Fisher-Yates algorithm)
function shuffleArray(array) {
    const shuffled = [...array]; // Create a copy
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

// Abbreviations dictionary
const abbreviations = {
    'ՔՇՕ': 'Քաղաքաշինության մասին ՀՀ օրենք',
    'ՃԳՄՕ': 'Ճարտարապետական գործունեության մասին ՀՀ օրենք',
    'ՔՕ': 'ՀՀ քաղաքացիական օրենսգիրք',
    'ՀՕ': 'ՀՀ հողային օրենսգիրք',
    'ՊՀՊՕ': 'Պատմության և մշակույթի անշարժ հուշարձանների / պատմական միջավայրի պահպանության և օգտագործման մասին ՀՀ օրենք',
    'ԿՈ': 'ՀՀ կառավարության որոշում',
    'ՃԷԿ': 'Ճարտարապետների էթիկայի կանոններ',
    'ԼՄՀ': 'Լիազոր պետական մարմնի ղեկավարի հրաման',
    'ՀՀՇՆ': 'ՀՀ շինարարական նորմեր'
};

// Extract materials (abbreviations and references) from text
function extractMaterials(text) {
    const materials = [];
    
    // Pattern to match: ԿՈ, 19.03.2015, N596-Ն
    const koPattern = /ԿՈ,?\s*\d{2}\.\d{2}\.\d{4},?\s*N\d+-Ն/g;
    const koMatches = text.match(koPattern);
    if (koMatches) {
        materials.push(...koMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ԿՈ, 20.04.2002, N438
    const ko438Pattern = /ԿՈ,?\s*20\.04\.2002,?\s*N438/g;
    const ko438Matches = text.match(ko438Pattern);
    if (ko438Matches) {
        materials.push(...ko438Matches.map(m => m.trim()));
    }
    
    // Pattern to match: ՀՕ, հոդվ. 60
    const hoPattern = /ՀՕ,?\s*հոդվ\.?\s*\d+/g;
    const hoMatches = text.match(hoPattern);
    if (hoMatches) {
        materials.push(...hoMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ՔՇՕ, հոդվ. 6 or ՔՇՕ, Հոդվ. 22.1
    const qshoPattern = /ՔՇՕ,?\s*[Հհ]ոդվ\.?\s*[\d.]+/g;
    const qshoMatches = text.match(qshoPattern);
    if (qshoMatches) {
        materials.push(...qshoMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ՊՀՊՕ, հոդվ. 6
    const phpPattern = /ՊՀՊՕ,?\s*հոդվ\.?\s*\d+/g;
    const phpMatches = text.match(phpPattern);
    if (phpMatches) {
        materials.push(...phpMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ՔՕ, հոդվ. 700
    const qoPattern = /ՔՕ,?\s*հոդվ\.?\s*\d+/g;
    const qoMatches = text.match(qoPattern);
    if (qoMatches) {
        materials.push(...qoMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ՔՕ, 760,2 2.6. Հեղինակային իրավ-նք
    const qo760Pattern = /ՔՕ,?\s*760,?\s*\d+\.?\s*\d+\.?\s*[Հհ]եղինակային\s*իրավ[-\s]*նք?/g;
    const qo760Matches = text.match(qo760Pattern);
    if (qo760Matches) {
        materials.push(...qo760Matches.map(m => m.trim()));
    }
    
    // Pattern to match: ՔՕ, 760,2 or ՔՕ, 760
    const qo760SimplePattern = /ՔՕ,?\s*760,?\s*\d*/g;
    const qo760SimpleMatches = text.match(qo760SimplePattern);
    if (qo760SimpleMatches) {
        materials.push(...qo760SimpleMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ՀՀՇՆ 30-01-2014, աղ.6 or ՀՀՇՆ 31-03-2018
    const hhshnPattern = /ՀՀՇՆ\s*\d{2}-\d{2}-\d{4}(,?\s*աղ\.?\d+)?/g;
    const hhshnMatches = text.match(hhshnPattern);
    if (hhshnMatches) {
        materials.push(...hhshnMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ԿՈ, 19.03.2015, N596-Ն 1.2.Ինժեներաերկրաբանական հետազննումներ (with topic)
    const koWithTopicPattern = /ԿՈ,?\s*\d{2}\.\d{2}\.\d{4},?\s*N\d+-Ն\s*[\d.]+\.\S+/g;
    const koWithTopicMatches = text.match(koWithTopicPattern);
    if (koWithTopicMatches) {
        materials.push(...koWithTopicMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ՃԳՄՕ, հոդվ. 13
    const jgmoPattern = /ՃԳՄՕ,?\s*հոդվ\.?\s*\d+/g;
    const jgmoMatches = text.match(jgmoPattern);
    if (jgmoMatches) {
        materials.push(...jgmoMatches.map(m => m.trim()));
    }
    
    // Pattern to match: ԿՈ,29.12,2011, N1920-Ն (without spaces)
    const koPattern2 = /ԿՈ,?\d{2}\.\d{2},?\d{4},?\s*N\d+-Ն/g;
    const koMatches2 = text.match(koPattern2);
    if (koMatches2) {
        materials.push(...koMatches2.map(m => m.trim()));
    }
    
    // Pattern to match: ԿՈ, 31.12.1999, N802
    const ko802Pattern = /ԿՈ,?\s*31\.12\.1999,?\s*N802/g;
    const ko802Matches = text.match(ko802Pattern);
    if (ko802Matches) {
        materials.push(...ko802Matches.map(m => m.trim()));
    }
    
    // Pattern to match: ԿՈ, 31.12.1999, N802 1.11.Քաղաքաշինական գործունեության վերահսկողություն (with topic)
    const ko802WithTopicPattern = /ԿՈ,?\s*31\.12\.1999,?\s*N802\s*[\d.]+\.[Ա-Ֆա-ֆ\s]+/g;
    const ko802WithTopicMatches = text.match(ko802WithTopicPattern);
    if (ko802WithTopicMatches) {
        materials.push(...ko802WithTopicMatches.map(m => m.trim()));
    }
    
    // Remove duplicates and return
    return [...new Set(materials)];
}

// Remove materials from answer text
function cleanAnswerText(text) {
    if (!text) return text;
    
    let cleaned = text;
    
    // Remove: ԿՈ, 19.03.2015, N596-Ն
    cleaned = cleaned.replace(/ԿՈ,?\s*\d{2}\.\d{2}\.\d{4},?\s*N\d+-Ն/g, '').trim();
    
    // Remove: ՀՕ, հոդվ. 60
    cleaned = cleaned.replace(/ՀՕ,?\s*հոդվ\.?\s*\d+/g, '').trim();
    
    // Remove: ՔՇՕ, հոդվ. 6 or ՔՇՕ, Հոդվ. 22.1
    cleaned = cleaned.replace(/ՔՇՕ,?\s*[Հհ]ոդվ\.?\s*[\d.]+/g, '').trim();
    
    // Remove: ՊՀՊՕ, հոդվ. 6
    cleaned = cleaned.replace(/ՊՀՊՕ,?\s*հոդվ\.?\s*\d+/g, '').trim();
    
    // Remove: ՔՕ, հոդվ. 700
    cleaned = cleaned.replace(/ՔՕ,?\s*հոդվ\.?\s*\d+/g, '').trim();
    
    // Remove: ՔՕ, 760,2 2.6. Հեղինակային իրավ-նք
    cleaned = cleaned.replace(/ՔՕ,?\s*760,?\s*\d+\.?\s*\d+\.?\s*[Հհ]եղինակային\s*իրավ[-\s]*նք?/g, '').trim();
    
    // Remove: ՔՕ, 760,2 or ՔՕ, 760
    cleaned = cleaned.replace(/ՔՕ,?\s*760,?\s*\d*/g, '').trim();
    
    // Remove: ՀՀՇՆ 30-01-2014, աղ.6 or ՀՀՇՆ 31-03-2018
    cleaned = cleaned.replace(/ՀՀՇՆ\s*\d{2}-\d{2}-\d{4}(,?\s*աղ\.?\d+)?/g, '').trim();
    
    // Remove: ՃԳՄՕ, հոդվ. 13
    cleaned = cleaned.replace(/ՃԳՄՕ,?\s*հոդվ\.?\s*\d+/g, '').trim();
    
    // Remove: ԿՈ,29.12,2011, N1920-Ն
    cleaned = cleaned.replace(/ԿՈ,?\d{2}\.\d{2},?\d{4},?\s*N\d+-Ն/g, '').trim();
    
    // Remove: ԿՈ, 20.04.2002, N438
    cleaned = cleaned.replace(/ԿՈ,?\s*20\.04\.2002,?\s*N438/g, '').trim();
    
    // Remove: ԿՈ, 31.12.1999, N802
    cleaned = cleaned.replace(/ԿՈ,?\s*31\.12\.1999,?\s*N802/g, '').trim();
    
    // Remove: ԿՈ, 31.12.1999, N802 1.11.Քաղաքաշինական գործունեության վերահսկողություն (with topic)
    cleaned = cleaned.replace(/ԿՈ,?\s*31\.12\.1999,?\s*N802\s*[\d.]+\.[Ա-Ֆա-ֆ\s]+/g, '').trim();
    
    // Remove: ԿՈ, 19.03.2015, N596-Ն 1.2.Ինժեներաերկրաբանական հետազննումներ (with topic)
    cleaned = cleaned.replace(/ԿՈ,?\s*\d{2}\.\d{2}\.\d{4},?\s*N\d+-Ն\s*[\d.]+\.\S+/g, '').trim();
    
    // Clean up extra spaces and commas
    cleaned = cleaned.replace(/\s+/g, ' ').trim();
    cleaned = cleaned.replace(/,\s*$/, ''); // Remove trailing comma
    cleaned = cleaned.replace(/^\s*,\s*/, ''); // Remove leading comma
    
    return cleaned;
}

// Display materials (used sources) for current question
function displayMaterials(question) {
    const materialsSection = document.getElementById('materials-section');
    const materialsList = document.getElementById('materials-list');
    
    if (!materialsSection || !materialsList) return;
    
    // First check if question has materials field
    if (question.materials && question.materials.trim()) {
        materialsList.textContent = question.materials;
        materialsSection.style.display = 'block';
        return;
    }
    
    // Collect all materials from answers
    const allMaterials = [];
    if (question.answers) {
        question.answers.forEach(answer => {
            const materials = extractMaterials(answer);
            allMaterials.push(...materials);
        });
    }
    
    // Remove duplicates
    const uniqueMaterials = [...new Set(allMaterials)];
    
    if (uniqueMaterials.length > 0) {
        // Create HTML for materials
        const materialsHtml = uniqueMaterials.map(material => {
            return material;
        }).join(', ');
        
        materialsList.textContent = materialsHtml;
        materialsSection.style.display = 'block';
    } else {
        materialsSection.style.display = 'none';
    }
}

// Find abbreviations in text (for abbreviation definitions)
function findAbbreviations(text) {
    const found = [];
    for (const abbrev in abbreviations) {
        if (text.includes(abbrev)) {
            found.push(abbrev);
        }
    }
    return found;
}

// Display abbreviations for current question
function displayAbbreviations(question) {
    const abbreviationsSection = document.getElementById('abbreviations-section');
    const abbreviationsList = document.getElementById('abbreviations-list');
    
    if (!abbreviationsSection || !abbreviationsList) return;
    
    // Find abbreviations in question and answers
    const questionText = question.question || '';
    const answersText = (question.answers || []).join(' ');
    const allText = questionText + ' ' + answersText;
    
    const foundAbbrevs = findAbbreviations(allText);
    
    if (foundAbbrevs.length > 0) {
        // Remove duplicates
        const uniqueAbbrevs = [...new Set(foundAbbrevs)];
        
        // Create HTML for abbreviations
        const abbrevsHtml = uniqueAbbrevs.map(abbrev => {
            return `<strong>${abbrev}</strong> – ${abbreviations[abbrev]}`;
        }).join('<br>');
        
        abbreviationsList.innerHTML = abbrevsHtml;
        abbreviationsSection.style.display = 'block';
    } else {
        abbreviationsSection.style.display = 'none';
    }
}

// Get quiz attempts count from localStorage
function getQuizAttempts() {
    const attempts = localStorage.getItem('quizAttempts');
    return attempts ? parseInt(attempts) : 0;
}

// Increment quiz attempts count
function incrementQuizAttempts() {
    const attempts = getQuizAttempts() + 1;
    localStorage.setItem('quizAttempts', attempts.toString());
    return attempts;
}

// Decrement quiz attempts count
function decrementQuizAttempts() {
    const attempts = Math.max(0, getQuizAttempts() - 1);
    localStorage.setItem('quizAttempts', attempts.toString());
    return attempts;
}

// Reset quiz attempts (when payment is verified)
function resetQuizAttempts() {
    localStorage.setItem('quizAttempts', '0');
}

// Reset quiz set attempts (when payment is verified)
function resetQuizSetAttempts() {
    quizSetAttempts = {};
    saveQuizSetAttempts();
}

// Reset quiz set questions used (when payment is verified)
function resetQuizSetQuestionsUsed() {
    quizSetQuestionsUsed = {};
    saveQuizSetQuestionsUsed();
}

// Load quiz set attempts from localStorage
function loadQuizSetAttempts() {
    const stored = localStorage.getItem('quizSetAttempts');
    quizSetAttempts = stored ? JSON.parse(stored) : {};
}

// Save quiz set attempts to localStorage
function saveQuizSetAttempts() {
    localStorage.setItem('quizSetAttempts', JSON.stringify(quizSetAttempts));
}

// Get attempts for a specific quiz set (1-18)
function getQuizSetAttempts(quizSetNumber) {
    return quizSetAttempts[quizSetNumber] || 0;
}

// Quiz set questions used tracking (tracks max questions reached per quiz set)
let quizSetQuestionsUsed = {};

// Load quiz set questions used from localStorage
function loadQuizSetQuestionsUsed() {
    const stored = localStorage.getItem('quizSetQuestionsUsed');
    quizSetQuestionsUsed = stored ? JSON.parse(stored) : {};
}

// Save quiz set questions used to localStorage
function saveQuizSetQuestionsUsed() {
    localStorage.setItem('quizSetQuestionsUsed', JSON.stringify(quizSetQuestionsUsed));
}

// Get questions used for a specific quiz set (1-18)
function getQuizSetQuestionsUsed(quizSetNumber) {
    return quizSetQuestionsUsed[quizSetNumber] || 0;
}

// Update questions used for a specific quiz set (tracks max questions reached)
function updateQuizSetQuestionsUsed(quizSetNumber, questionsReached) {
    const current = getQuizSetQuestionsUsed(quizSetNumber);
    if (questionsReached > current) {
        quizSetQuestionsUsed[quizSetNumber] = questionsReached;
        saveQuizSetQuestionsUsed();
    }
}

// Increment attempts for a specific quiz set
function incrementQuizSetAttempt(quizSetNumber) {
    const current = getQuizSetAttempts(quizSetNumber);
    quizSetAttempts[quizSetNumber] = current + 1;
    saveQuizSetAttempts();
    
    // Also save to Google Sheets immediately to persist across sessions
    saveQuizSetAttemptsToCloud(quizSetNumber, quizSetAttempts[quizSetNumber]).catch(err => {
        // Don't fail if cloud save fails - localStorage is still saved
    });
    
    return quizSetAttempts[quizSetNumber];
}

// Save quiz set attempts to Google Sheets
async function saveQuizSetAttemptsToCloud(quizSetNumber, attempts) {
    try {
        const paymentCode = localStorage.getItem('paymentCode') || '';
        if (!paymentCode) {
            return;
        }
        
        // Note: We don't track 'start' here because:
        // 1. When quiz is completed, 'complete' event is already tracked separately
        // 2. When quiz is started, 'start' event is already tracked in startQuiz()
        // This function is called when incrementing attempts after completion,
        // so the 'complete' event will handle the attempt counting in getQuizUsage
        // We just need to ensure localStorage is synced, which is already done
        } catch (error) {
        }
}

// Load quiz set attempts from Google Sheets (fallback if localStorage is empty)
async function loadQuizSetAttemptsFromCloud() {
    try {
        const paymentCode = localStorage.getItem('paymentCode') || '';
        if (!paymentCode) {
            return;
        }
        
        // Get quiz usage from Google Apps Script
        const callbackName = 'handleGetQuizUsageForAttempts' + Date.now();
        
        return new Promise((resolve) => {
            window[callbackName] = function(result) {
                // Clean up
                const scripts = document.querySelectorAll('script[src*="getQuizUsage"]');
                scripts.forEach(script => {
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                });
                delete window[callbackName];
                
                if (result && result.success && result.quizUsage) {
                    // Convert quizUsage to quizSetAttempts format
                    const loadedAttempts = {};
                    const loadedQuestionsUsed = {};
                    for (let i = 1; i <= 18; i++) {
                        const quizSet = result.quizUsage[i.toString()] || result.quizUsage[i];
                        if (quizSet && quizSet.attempts > 0) {
                            loadedAttempts[i.toString()] = quizSet.attempts;
                        }
                        if (quizSet && quizSet.questionsUsed > 0) {
                            loadedQuestionsUsed[i.toString()] = quizSet.questionsUsed;
                        }
                    }
                    
                    // Merge with localStorage (use higher value)
                    loadQuizSetAttempts();
                    loadQuizSetQuestionsUsed();
                    for (const [setNumber, attempts] of Object.entries(loadedAttempts)) {
                        const current = getQuizSetAttempts(setNumber);
                        if (attempts > current) {
                            quizSetAttempts[setNumber] = attempts;
                        }
                    }
                    saveQuizSetAttempts();
                    
                    // Merge questions used (use higher value)
                    for (const [setNumber, questionsUsed] of Object.entries(loadedQuestionsUsed)) {
                        const current = getQuizSetQuestionsUsed(setNumber);
                        if (questionsUsed > current) {
                            quizSetQuestionsUsed[setNumber] = questionsUsed;
                        }
                    }
                    saveQuizSetQuestionsUsed();
                    
                    // Update attempts display if quiz is already started
                    if (typeof currentQuizSetIndex !== 'undefined' && currentQuizSetIndex >= 0) {
                        const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
                        const attempts = getQuizSetAttempts(quizSetNumber.toString());
                        updateAttemptsDisplay(attempts);
                    }
                    
                    resolve(quizSetAttempts);
                } else {
                    resolve(null);
                }
            };
            
            const script = document.createElement('script');
            script.src = PAYMENT_WEB_APP_URL + '?action=getQuizUsage&paymentCode=' + encodeURIComponent(paymentCode) + '&callback=' + callbackName;
            script.onerror = function() {
                delete window[callbackName];
                resolve(null);
            };
            document.body.appendChild(script);
            
            // Timeout after 10 seconds
            setTimeout(() => {
                if (window[callbackName]) {
                    delete window[callbackName];
                    resolve(null);
                }
            }, 10000);
        });
    } catch (error) {
        return null;
    }
}

// Find next available quiz set (not exhausted - less than 3 attempts)
function findNextAvailableQuizSet() {
    for (let i = 0; i < quizSets.length; i++) {
        const quizSetNumber = i < 17 ? i + 1 : 18;
        const attempts = getQuizSetAttempts(quizSetNumber);
        if (attempts < 3) {
            return i;
        }
    }
    return -1; // All exhausted
}

// Update exhausted quiz sets display
function updateExhaustedQuizSetsDisplay() {
    const exhaustedDisplay = document.getElementById('exhausted-quiz-sets-display');
    const exhaustedText = document.getElementById('exhausted-quiz-sets-text');
    
    if (!exhaustedDisplay || !exhaustedText) return;
    
    const exhausted = [];
    for (let i = 0; i < quizSets.length; i++) {
        const quizSetNumber = i < 17 ? i + 1 : 18;
        const attempts = getQuizSetAttempts(quizSetNumber);
        if (attempts >= 3) {
            exhausted.push(quizSetNumber);
        }
    }
    
    if (exhausted.length > 0) {
        exhaustedText.textContent = `Հարցաթերթիկ ${exhausted.join(', ')} սպառված`;
        exhaustedDisplay.style.display = 'block';
    } else {
        exhaustedDisplay.style.display = 'none';
    }
}



// DOM elements
const paymentSection = document.getElementById('payment-section');
const startSection = document.getElementById('start-section');
const topicSection = document.getElementById('topic-section');
const questionSection = document.getElementById('question-section');
const answersSection = document.getElementById('answers-section');
const nextSection = document.getElementById('next-section');
const resultsSection = document.getElementById('results-section');
const startBtn = document.getElementById('start-btn');
const backToPaymentBtn = document.getElementById('back-to-payment-btn');
const nextBtn = document.getElementById('next-btn');
const restartBtn = document.getElementById('restart-btn');
const repeatQuizBtn = document.getElementById('repeat-quiz-btn');
const changeQuizBtn = document.getElementById('change-quiz-btn');
const viewAnswersBtn = document.getElementById('view-answers-btn');
const verifyPaymentBtn = document.getElementById('verify-payment-btn');
const answersReview = document.getElementById('answers-review');
const answersList = document.getElementById('answers-list');
const questionNumber = document.getElementById('question-number');
const totalQuestions = document.getElementById('total-questions');
const scoreDisplay = document.getElementById('score');
const topicTitle = document.getElementById('topic-title');
const questionText = document.getElementById('question-text');
const paymentStatus = document.getElementById('payment-status');

// Payment system
const PAYMENT_AMOUNT = 15000; // 15,000 դրամ
const PAYMENT_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbwarQPmrBy3dLKYQJZuSU_7qVPgrdjZWUAet8qS_MXC3cA4kcQkpJlkcZIWwt84bDTajg/exec';

// Submit payment request
async function submitPaymentRequest(event) {
    event.preventDefault();
    
    const submitBtn = document.getElementById('submit-payment-btn');
    const statusDiv = document.getElementById('payment-request-status');
    const form = document.getElementById('payment-form');
    
    // Get form data
    const formData = {
        name: document.getElementById('payment-name').value.trim(),
        phone: document.getElementById('payment-phone').value.trim(),
        email: document.getElementById('payment-email').value.trim(),
        paymentMethod: document.getElementById('payment-method').value,
        message: document.getElementById('payment-message').value.trim(),
        timestamp: new Date().toISOString()
    };
    
    // Validate
    if (!formData.name || !formData.phone || !formData.paymentMethod) {
        statusDiv.innerHTML = '<div class="payment-status error">⚠️ Խնդրում ենք լրացնել բոլոր պարտադիր դաշտերը</div>';
        return;
    }
    
    // Disable button and show loading
    submitBtn.disabled = true;
    submitBtn.textContent = '⏳ Ուղարկվում է...';
    statusDiv.innerHTML = '<div class="payment-status info">🔄 Վճարման հարցումը ուղարկվում է...</div>';
    
    try {
        // Try Netlify Forms first, then fallback to Google Apps Script
        const netlifyFormData = new FormData();
        netlifyFormData.append('form-name', 'payment-request');
        netlifyFormData.append('name', formData.name);
        netlifyFormData.append('phone', formData.phone);
        netlifyFormData.append('email', formData.email || '');
        netlifyFormData.append('paymentMethod', formData.paymentMethod);
        netlifyFormData.append('message', formData.message || '');
        netlifyFormData.append('timestamp', formData.timestamp);
        
        // Submit to Netlify Forms
        try {
            const netlifyResponse = await fetch('/', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: new URLSearchParams(netlifyFormData).toString()
            });
            
            if (netlifyResponse.ok) {
                statusDiv.innerHTML = '<div class="payment-status success">✅ Վճարման հարցումը հաջողությամբ ուղարկված է!<br>Վճարիր 15,000 դրամ և սպասիր վճարման կոդին email-ով:</div>';
                
                // Hide form and show payment code input (after request)
                document.getElementById('payment-request-form').style.display = 'none';
                document.getElementById('payment-code-section').style.display = 'none';
                document.getElementById('payment-code-section-after-request').style.display = 'block';
                
                // Scroll to payment code section
                document.getElementById('payment-code-section-after-request').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                
                submitBtn.disabled = false;
                submitBtn.textContent = '📤 Ուղարկել Վճարման Հարցում';
                return;
            }
        } catch (netlifyError) {
            }
        
        // Fallback to Google Apps Script using JSONP
        // Use a simple callback name that passes sanitization
        const callbackName = 'handlePaymentRequest' + Date.now();
        
        // Create callback function
        window[callbackName] = function(result) {
            // Remove script tag
            const scripts = document.querySelectorAll('script[src*="savePaymentRequest"]');
            scripts.forEach(script => {
                if (script.parentNode) {
                    script.parentNode.removeChild(script);
                }
            });
            
            // Clean up callback
            delete window[callbackName];
            
            if (result && result.success) {
                statusDiv.innerHTML = '<div class="payment-status success">✅ Վճարման հարցումը հաջողությամբ ուղարկված է!<br>Վճարիր 15,000 դրամ և սպասիր վճարման կոդին email-ով:</div>';
                
                // Hide form and show payment code input (after request)
                const requestForm = document.getElementById('payment-request-form');
                const codeSection = document.getElementById('payment-code-section');
                const codeSectionAfter = document.getElementById('payment-code-section-after-request');
                
                if (requestForm) requestForm.style.display = 'none';
                if (codeSection) codeSection.style.display = 'none';
                if (codeSectionAfter) {
                    codeSectionAfter.style.display = 'block';
                    codeSectionAfter.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
                
                // Save user name to localStorage for welcome message
                if (formData.name && formData.name.trim()) {
                    localStorage.setItem('userName', formData.name.trim());
                }
                
                submitBtn.disabled = false;
                submitBtn.textContent = '📤 Ուղարկել Վճարման Հարցում';
            } else {
                statusDiv.innerHTML = '<div class="payment-status error">❌ Սխալ: Վճարման հարցումը չի կարող ուղարկվել: ' + (result?.error || 'Unknown error') + '</div>';
                submitBtn.disabled = false;
                submitBtn.textContent = '📤 Ուղարկել Վճարման Հարցում';
            }
        };
        
        // Build JSONP URL
        const params = new URLSearchParams({
            action: 'savePaymentRequest',
            name: formData.name,
            phone: formData.phone,
            email: formData.email || '',
            paymentMethod: formData.paymentMethod,
            message: formData.message || '',
            timestamp: formData.timestamp,
            callback: callbackName
        });
        
        // Create and append script tag for JSONP
        const script = document.createElement('script');
        const fullUrl = PAYMENT_WEB_APP_URL + '?' + params.toString();
        script.src = fullUrl;
        
        // Add error handler
        script.onerror = function(error) {
            // Remove script tag
            if (script.parentNode) {
                script.parentNode.removeChild(script);
            }
            
            // Clean up callback
            if (window[callbackName]) {
                delete window[callbackName];
            }
            
            // Show user-friendly error message
            statusDiv.innerHTML = '<div class="payment-status error">❌ Սխալ: Վճարման հարցումը չի կարող ուղարկվել:<br>Ստուգեք ինտերնետ կապը կամ փորձեք ավելի ուշ</div>';
            submitBtn.disabled = false;
            submitBtn.textContent = '📤 Ուղարկել Վճարման Հարցում';
        };
        
        // Add load handler (but note: JSONP success is handled by callback)
        script.onload = function() {
            };
        
        // Append script to body
        document.body.appendChild(script);
        
        // Also set a timeout to detect if callback never fires
        const timeoutId = setTimeout(() => {
            if (window[callbackName]) {
                statusDiv.innerHTML = '<div class="payment-status error">❌ Սխալ: Վճարման հարցումը չի կարող ուղարկվել:<br>Timeout - ստուգեք Google Apps Script deployment-ը<br>Կամ փորձեք ավելի ուշ</div>';
                submitBtn.disabled = false;
                submitBtn.textContent = '📤 Ուղարկել Վճարման Հարցում';
                
                // Clean up
                if (script.parentNode) {
                    script.parentNode.removeChild(script);
                }
                delete window[callbackName];
            }
        }, 30000); // 30 second timeout
        
        // Store timeout ID in callback function to clear it on success
        const originalCallback = window[callbackName];
        window[callbackName] = function(result) {
            clearTimeout(timeoutId);
            // Remove script tag
            if (script.parentNode) {
                script.parentNode.removeChild(script);
            }
            if (originalCallback) {
                originalCallback(result);
            }
        };
        
        // Set timeout for JSONP request
        setTimeout(() => {
            if (window[callbackName]) {
                const scripts = document.querySelectorAll('script[src*="savePaymentRequest"]');
                scripts.forEach(script => {
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                });
                delete window[callbackName];
                
                // Try no-cors as final fallback
                const formBody = new URLSearchParams({
                    action: 'savePaymentRequest',
                    name: formData.name,
                    phone: formData.phone,
                    email: formData.email || '',
                    paymentMethod: formData.paymentMethod,
                    message: formData.message || '',
                    timestamp: formData.timestamp
                }).toString();
                
                fetch(PAYMENT_WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formBody
                }).then(() => {
                    statusDiv.innerHTML = '<div class="payment-status success">✅ Վճարման հարցումը ուղարկված է (no-cors mode):<br>Վճարիր 15,000 դրամ և սպասիր վճարման կոդին email-ով:</div>';
                    
                    const requestForm = document.getElementById('payment-request-form');
                    const codeSection = document.getElementById('payment-code-section');
                    const codeSectionAfter = document.getElementById('payment-code-section-after-request');
                    
                    if (requestForm) requestForm.style.display = 'none';
                    if (codeSection) codeSection.style.display = 'none';
                    if (codeSectionAfter) {
                        codeSectionAfter.style.display = 'block';
                        codeSectionAfter.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                    
                    submitBtn.disabled = false;
                    submitBtn.textContent = '📤 Ուղարկել Վճարման Հարցում';
                }).catch(() => {
                    statusDiv.innerHTML = '<div class="payment-status error">❌ Սխալ: Վճարման հարցումը չի կարող ուղարկվել</div>';
                    submitBtn.disabled = false;
                    submitBtn.textContent = '📤 Ուղարկել Վճարման Հարցում';
                });
            }
        }, 10000); // 10 second timeout
        
    } catch (error) {
        statusDiv.innerHTML = '<div class="payment-status error">❌ Սխալ: ' + error.message + '<br>Խնդրում ենք փորձել կրկին:</div>';
        submitBtn.disabled = false;
        submitBtn.textContent = '📤 Ուղարկել Վճարման Հարցում';
    }
}

// Get device fingerprint
function getDeviceFingerprint() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.fillText('Device fingerprint', 2, 2);
    
    const fingerprint = {
        screen: `${screen.width}x${screen.height}`,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        language: navigator.language,
        platform: navigator.platform,
        userAgent: navigator.userAgent.substring(0, 50),
        canvas: canvas.toDataURL().substring(0, 50),
        hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
        deviceMemory: navigator.deviceMemory || 'unknown'
    };
    
    return btoa(JSON.stringify(fingerprint)).substring(0, 64);
}

// Get unique browser session ID (unique per browser/tab combination)
// This ensures different browsers on the same computer have different session IDs
function getBrowserSessionId() {
    let sessionId = sessionStorage.getItem('browserSessionId');
    if (!sessionId) {
        // Generate unique session ID: device fingerprint + random string + timestamp
        const deviceFp = getDeviceFingerprint();
        const randomPart = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        const timestamp = Date.now();
        sessionId = btoa(deviceFp + randomPart + timestamp).substring(0, 64);
        sessionStorage.setItem('browserSessionId', sessionId);
    }
    return sessionId;
}

// Get IP address (via external service)
async function getUserIP() {
    try {
        const response = await fetch('https://api.ipify.org?format=json');
        const data = await response.json();
        return data.ip || 'unknown';
    } catch (error) {
        return 'unknown';
    }
}

// Check if user has paid (with security checks)
async function checkPaymentStatus() {
    const paymentToken = localStorage.getItem('paymentToken');
    const paymentTimestamp = localStorage.getItem('paymentTimestamp');
    const storedIP = localStorage.getItem('paymentIP');
    const storedDevice = localStorage.getItem('paymentDevice');
    
    if (paymentToken && paymentTimestamp) {
        const now = new Date().getTime();
        const paymentTime = parseInt(paymentTimestamp);
        const hoursSincePayment = (now - paymentTime) / (1000 * 60 * 60);
        
        if (hoursSincePayment < 24) {
            // Security checks
            // IMPORTANT: Do not break the user flow on legitimate changes (IP can change, browser can restart).
            // Especially for localhost/dev testing, we never want to invalidate payment state.
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const enforceBinding = !isLocalhost && localStorage.getItem('enforcePaymentBinding') === 'true';
            
            const currentIP = enforceBinding ? await getUserIP() : 'unknown';
            const currentDevice = enforceBinding ? getDeviceFingerprint() : storedDevice;
            
            // Check IP match
            if (enforceBinding && storedIP && storedIP !== 'unknown' && currentIP !== 'unknown' && storedIP !== currentIP) {
                // Do NOT clear token; keep user paid state
            }
            
            // Check device fingerprint match
            if (enforceBinding && storedDevice && storedDevice !== currentDevice) {
                // Do NOT clear token; keep user paid state
            }
            
            return { paid: true, token: paymentToken };
        } else {
            localStorage.removeItem('paymentToken');
            localStorage.removeItem('paymentTimestamp');
            localStorage.removeItem('paymentIP');
            localStorage.removeItem('paymentDevice');
            return { paid: false };
        }
    }
    
    return { paid: false };
}

// Quick verification: check if payment code exists in Google Sheets (without full verification)
async function verifyPaymentCodeQuick(paymentCode) {
    if (!paymentCode) {
        return false;
    }
    
    // Special code: karmik1996
    const codeUpper = paymentCode.toUpperCase();
    if (codeUpper === 'KARMIK1996') {
        return true;
    }
    
    return new Promise((resolve) => {
        const callbackName = 'handleVerifyPaymentCodeQuick' + Date.now();
        const timeout = setTimeout(() => {
            if (window[callbackName]) {
                delete window[callbackName];
            }
            // On timeout, allow access (fail open for better UX)
            resolve(true);
        }, 5000); // 5 second timeout
        
        window[callbackName] = function(result) {
            clearTimeout(timeout);
            // Clean up
            delete window[callbackName];
            const scripts = document.querySelectorAll('script[src*="verify"]');
            scripts.forEach(script => {
                if (script.parentNode && script.src.includes('action=verify')) {
                    script.parentNode.removeChild(script);
                }
            });
            
            // Check if code exists (verified = true means code was found)
            const exists = result && result.success && result.verified === true;
            resolve(exists);
        };
        
        const script = document.createElement('script');
        script.src = PAYMENT_WEB_APP_URL + '?action=verify&code=' + encodeURIComponent(paymentCode) + '&ip=unknown&device=unknown&callback=' + callbackName;
        script.onerror = function() {
            clearTimeout(timeout);
            if (window[callbackName]) {
                delete window[callbackName];
            }
            // On error, allow access (fail open for better UX)
            resolve(true);
        };
        document.body.appendChild(script);
    });
}

// Verify payment code
async function verifyPaymentCode() {
    // Check both payment code inputs (main and after-request)
    const paymentCodeInput = document.getElementById('payment-code');
    const paymentCodeInputAfter = document.getElementById('payment-code-after');
    const code = (paymentCodeInput?.value.trim() || paymentCodeInputAfter?.value.trim() || '').trim();
    
    if (!code) {
        paymentStatus.innerHTML = '<div class="payment-status error">⚠️ Մուտքագրեք վճարման կոդ</div>';
        return;
    }
    
    // Check if this code has saved progress (will be checked again in initGame after payment verification)
    // Note: loadQuizProgress is async, so we'll check in initGame
    
    verifyPaymentBtn.disabled = true;
    verifyPaymentBtn.textContent = '⏳ Ստուգվում է...';
    paymentStatus.innerHTML = '<div class="payment-status info">🔄 Ստուգվում է վճարման կոդը...</div>';
    
    try {
        // Special code: karmik1996
        const codeUpper = code.toUpperCase();
        
        if (codeUpper === 'KARMIK1996') {
            // Skip getUserIP for special code to speed up verification
            const userIP = '127.0.0.1';
            const deviceFingerprint = getDeviceFingerprint();
            
            // Simulate successful verification for special code
            const token = 'PAID_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('paymentToken', token);
            localStorage.setItem('paymentTimestamp', new Date().getTime().toString());
            localStorage.setItem('paymentCode', codeUpper);
            localStorage.setItem('paymentIP', userIP);
            localStorage.setItem('paymentDevice', deviceFingerprint);
            
            // Reset quiz attempts when payment is verified (new payment = new 3 attempts)
            resetQuizAttempts();
            resetQuizSetAttempts(); // Also reset quiz set attempts
            resetQuizSetQuestionsUsed(); // Also reset quiz set questions used
            
            // CRITICAL: Load attempts from cloud to sync across browsers/devices
            // This ensures that attempts from other browsers are visible
            loadQuizSetAttemptsFromCloud().then(cloudAttempts => {
                if (cloudAttempts) {
                    }
            });
            
            paymentStatus.innerHTML = '<div class="payment-status success">✅ Վճարման կոդը հաստատված է! Հարցաթերթիկները բացվում են...</div>';
            
            // Hide payment section and show start section with smooth transition
            setTimeout(() => {
                const paymentSectionEl = document.getElementById('payment-section');
                const startSectionEl = document.getElementById('start-section');
                if (paymentSectionEl) paymentSectionEl.style.display = 'none';
                if (startSectionEl) startSectionEl.style.display = 'block';
                
                // Initialize content protection (watermark + blur)
                initializeContentProtection();
                
                // Show welcome message with user name
                const welcomeMessage = document.getElementById('welcome-message');
                const welcomeGreeting = document.getElementById('welcome-greeting');
                const welcomeInfo = document.getElementById('welcome-info');
                
                // Get user name from localStorage
                let userName = localStorage.getItem('userName') || '';
                
                // If no name in localStorage, try to get from payment request form
                if (!userName) {
                    const nameInput = document.getElementById('payment-name') || document.getElementById('name');
                    if (nameInput && nameInput.value.trim()) {
                        userName = nameInput.value.trim();
                        localStorage.setItem('userName', userName);
                    }
                }
                
                // Display welcome message if we have a name
                if (userName && welcomeMessage && welcomeGreeting && welcomeInfo) {
                    welcomeGreeting.textContent = `Բարև, ${userName}! 👋`;
                    welcomeInfo.textContent = 'Բարի գալուստ հարցաթերթիկներին:';
                    welcomeMessage.style.display = 'block';
                } else if (welcomeMessage) {
                    welcomeMessage.style.display = 'none';
                }
                
                // Update attempts display
                const attemptsDisplay = document.getElementById('quiz-attempts');
                if (attemptsDisplay) {
                    // Calculate total used attempts
                    loadQuizSetAttempts();
                    const totalQuizSets = 18;
                    const maxAttemptsPerSet = 3;
                    const totalMaxAttempts = totalQuizSets * maxAttemptsPerSet; // 54
                    
                    let totalUsedAttempts = 0;
                    for (let i = 1; i <= totalQuizSets; i++) {
                        const setAttempts = getQuizSetAttempts(i.toString());
                        totalUsedAttempts += setAttempts;
                    }
                    
                    const remaining = Math.max(0, totalMaxAttempts - totalUsedAttempts);
                    attemptsDisplay.innerHTML = `Առկա է <strong>18 թեստ</strong>, ունեք իրավունք անցնելու ամեն թեստը <strong>3 անգամ</strong>։<br><strong>${totalUsedAttempts}/${totalMaxAttempts} օգտագործված</strong>${remaining > 0 ? `, <strong>մնաց ${remaining}</strong>` : ''}`;
                    if (remaining === 0) {
                        attemptsDisplay.style.color = '#dc3545';
                    } else {
                        attemptsDisplay.style.color = '#28a745';
                    }
                }
                // Auto-scroll to top for better UX
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                // CRITICAL: Check if there's saved progress to restore (cross-device sync)
                // Load progress after payment verification to continue from where user left off
                setTimeout(async () => {
                    try {
                        const savedProgress = await loadQuizProgress();
                        const progressInfo = savedProgress ? {
                            hasProgress: true,
                            gameStarted: savedProgress.gameStarted,
                            paymentCode: savedProgress.paymentCode,
                            currentCode: codeUpper,
                            match: savedProgress.paymentCode === codeUpper,
                            questionIndex: savedProgress.currentQuestionIndex
                        } : { hasProgress: false };
                        
                        // Check if progress matches current payment code (case-insensitive)
                        const progressCode = (savedProgress?.paymentCode || '').toUpperCase();
                        const currentCode = (codeUpper || '').toUpperCase();
                        const paymentCodeMatches = progressCode === currentCode;
                        
                        if (savedProgress && savedProgress.gameStarted && paymentCodeMatches) {
                            // Restore progress and continue quiz from where user left off
                            currentQuestionIndex = savedProgress.currentQuestionIndex || 0;
                            score = savedProgress.score || 0;
                            userAnswers = savedProgress.userAnswers || [];
                            gameStarted = savedProgress.gameStarted;
                            if (typeof currentQuizSetIndex !== 'undefined' && savedProgress.currentQuizSetIndex >= 0) {
                                currentQuizSetIndex = savedProgress.currentQuizSetIndex;
                            }
                            
                            // Restore shuffled quiz data
                            if (savedProgress.shuffledQuizData && savedProgress.shuffledQuizData.length > 0) {
                                shuffledQuizData = [];
                                for (const questionText of savedProgress.shuffledQuizData) {
                                    const foundQuestion = quizData.find(q => q.question === questionText);
                                    if (foundQuestion) {
                                        shuffledQuizData.push(foundQuestion);
                                    }
                                }
                            }
                            
                            // Restore quiz sets if needed
                            if (typeof quizSets === 'undefined' || quizSets.length === 0) {
                                const orderedQuizData = [...quizData];
                                quizSets = [];
                                quizSetResults = [];
                                for (let i = 0; i < 17; i++) {
                                    quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
                                    quizSetResults.push({ correct: 0, wrong: 0 });
                                }
                                quizSets.push(orderedQuizData.slice(170, 175));
                                quizSetResults.push({ correct: 0, wrong: 0 });
                            }
                            
                            // Restore UI to quiz state (hide start section, show quiz)
                            if (startSectionEl) startSectionEl.style.display = 'none';
                            if (topicSection) topicSection.style.display = 'block';
                            if (questionSection) questionSection.style.display = 'block';
                            if (answersSection) answersSection.style.display = 'flex';
                            if (nextSection) nextSection.style.display = 'none';
                            if (resultsSection) resultsSection.style.display = 'none';
                            
                            // Load the current question
                            loadQuestion();
                            
                            // CRITICAL: Explicitly update question number display after restore
                            // Sometimes loadQuestion() runs before UI elements are fully ready
                            setTimeout(() => {
                                const questionInSet = currentQuestionIndex + 1;
                                const totalInSet = shuffledQuizData.length;
                                const questionNumberEl = document.getElementById('question-number');
                                if (questionNumberEl) {
                                    questionNumberEl.textContent = questionInSet;
                                }
                                const totalQuestionsSpan = document.getElementById('total-questions');
                                if (totalQuestionsSpan) {
                                    totalQuestionsSpan.textContent = totalInSet;
                                }
                                const quizSetNumberDisplay = document.getElementById('quiz-set-number-display');
                                if (quizSetNumberDisplay && typeof currentQuizSetIndex !== 'undefined' && currentQuizSetIndex >= 0) {
                                    if (currentQuizSetIndex < 17) {
                                        quizSetNumberDisplay.textContent = currentQuizSetIndex + 1;
                                    } else {
                                        quizSetNumberDisplay.textContent = 18;
                                    }
                                }
                                // Question number updated
                            }, 100);
                            
                            progressRestored = true;
                            gameInitialized = true;
                            
                            // Start periodic session validity check (prevent multiple simultaneous sessions)
                            startSessionValidityCheck();
                            
                            // Update attempts display for current quiz set
                            if (typeof currentQuizSetIndex !== 'undefined' && currentQuizSetIndex >= 0) {
                                loadQuizSetAttempts();
                                const setAttempts = getQuizSetAttempts((currentQuizSetIndex + 1).toString());
                                const attemptsDisplay = document.getElementById('quiz-attempts');
                                if (attemptsDisplay) {
                                    loadQuizSetQuestionsUsed();
                                    const questionsUsed = getQuizSetQuestionsUsed((currentQuizSetIndex + 1).toString());
                                    if (questionsUsed > 0) {
                                        attemptsDisplay.innerHTML = `Հարցաթերթիկ #${currentQuizSetIndex + 1} - ${questionsUsed} հարց օգտագործված, <strong>${setAttempts}/3</strong> փորձ`;
                                    } else {
                                        attemptsDisplay.innerHTML = `Հարցաթերթիկ #${currentQuizSetIndex + 1} - Փորձեր: <strong>${setAttempts}/3</strong>`;
                                    }
                                    if (setAttempts >= 3) {
                                        attemptsDisplay.style.color = '#dc3545';
                                    } else {
                                        attemptsDisplay.style.color = '#28a745';
                                    }
                                }
                            }
                            return; // Don't focus on name input - user is already in quiz
                        }
                    } catch (error) {
                        // Error loading progress
                    }
                    
                    // If no progress to restore, focus on name input as usual
                    const userNameInput = document.getElementById('user-name');
                    if (userNameInput) {
                        userNameInput.focus();
                    }
                }, 500); // Small delay to let UI settle before restoring progress
            }, 1500);
            
            // Re-enable button
            verifyPaymentBtn.disabled = false;
            verifyPaymentBtn.textContent = '✅ Ստուգել Վճարում';
            return;
        }
        
        // Get security info before verification (only for non-special codes)
        const userIP = await getUserIP();
        const deviceFingerprint = getDeviceFingerprint();
        
        // Use JSONP instead of fetch to avoid CORS issues
        const callbackName = 'handleVerifyPayment' + Date.now();
        
        // Create promise for JSONP callback
        const verifyPromise = new Promise((resolve, reject) => {
            window[callbackName] = function(result) {
                // Clean up
                const scripts = document.querySelectorAll('script[src*="action=verify"]');
                scripts.forEach(script => {
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                });
                delete window[callbackName];
                
                if (result && result.success && result.verified) {
                    resolve(result);
                } else {
                    reject(new Error(result?.error || 'Payment verification failed'));
                }
            };
            
            // Build JSONP URL
            const url = PAYMENT_WEB_APP_URL + '?action=verify&code=' + encodeURIComponent(code) + '&ip=' + encodeURIComponent(userIP) + '&device=' + encodeURIComponent(deviceFingerprint) + '&callback=' + callbackName;
            
            // Create and append script tag
            const script = document.createElement('script');
            script.src = url;
            script.onerror = function(error) {
                delete window[callbackName];
                reject(new Error('Script load error'));
            };
            document.body.appendChild(script);
            
            // Set timeout
            setTimeout(() => {
                if (window[callbackName]) {
                    delete window[callbackName];
                    reject(new Error('Request timeout'));
                }
            }, 30000); // 30 second timeout
        });
        
        const data = await verifyPromise;
        
        // Check if payment code was not found or verification failed
        if (!data.success || !data.verified) {
            const errorMessage = data?.error || 'Վճարման կոդը չի գտնվել կամ անվավեր է';
            paymentStatus.innerHTML = `<div class="payment-status error">❌ ${errorMessage}</div>`;
            verifyPaymentBtn.disabled = false;
            verifyPaymentBtn.textContent = '✅ Ստուգել Վճարում';
            return;
        }
        
        if (data.success && data.verified) {
            // Check if payment code has changed BEFORE saving new code
            const previousPaymentCode = localStorage.getItem('paymentCode') || '';
            const currentPaymentCode = code;
            const paymentCodeChanged = previousPaymentCode !== currentPaymentCode;
            
            // Security info already retrieved above (userIP and deviceFingerprint)
            const token = 'PAID_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('paymentToken', token);
            localStorage.setItem('paymentTimestamp', new Date().getTime().toString());
            localStorage.setItem('paymentIP', userIP);
            localStorage.setItem('paymentDevice', deviceFingerprint);
            // Save payment code to localStorage for progress recovery
            localStorage.setItem('paymentCode', code);
            
            // Send security info to Google Sheets
            try {
                await fetch(PAYMENT_WEB_APP_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        action: 'updatePaymentSecurity',
                        code: code,
                        ip: userIP,
                        device: deviceFingerprint
                    }).toString()
                });
            } catch (error) {
                }
            
            // Only reset quiz attempts if this is a NEW payment (not re-verification)
            // If payment code changed, reset attempts (new payment)
            if (paymentCodeChanged) {
                // New payment code - reset attempts
                resetQuizAttempts();
                resetQuizSetAttempts();
                resetQuizSetQuestionsUsed();
                } else {
                // Re-verification with same code - keep existing attempts
                loadQuizSetAttempts();
                }
            
            // CRITICAL: Always load attempts from cloud to sync across browsers/devices
            // This ensures that attempts from other browsers are visible
            loadQuizSetAttemptsFromCloud().then(cloudAttempts => {
                if (cloudAttempts) {
                    // Update attempts display if visible
                    const attemptsDisplay = document.getElementById('quiz-attempts');
                    if (attemptsDisplay) {
                        const totalQuizSets = 18;
                        const maxAttemptsPerSet = 3;
                        const totalMaxAttempts = totalQuizSets * maxAttemptsPerSet; // 54
                        
                        let totalUsedAttempts = 0;
                        for (let i = 1; i <= totalQuizSets; i++) {
                            const setAttempts = getQuizSetAttempts(i.toString());
                            totalUsedAttempts += setAttempts;
                        }
                        
                        const remaining = Math.max(0, totalMaxAttempts - totalUsedAttempts);
                        attemptsDisplay.innerHTML = `Առկա է <strong>18 թեստ</strong>, ունեք իրավունք անցնելու ամեն թեստը <strong>3 անգամ</strong>։<br><strong>${totalUsedAttempts}/${totalMaxAttempts} օգտագործված</strong>${remaining > 0 ? `, <strong>մնաց ${remaining}</strong>` : ''}`;
                    }
                }
            });
            
            // Don't clear quiz progress on re-verification - allow user to continue
            // Only clear if starting fresh
            // localStorage.removeItem('quizProgress');
            
            paymentStatus.innerHTML = '<div class="payment-status success">✅ Վճարման կոդը հաստատված է! Հարցաթերթիկները բացվում են...</div>';
            
            // Hide payment section and show start section with smooth transition
            setTimeout(() => {
                if (paymentSection) paymentSection.style.display = 'none';
                if (startSection) startSection.style.display = 'block';
                
                // Show welcome message with user name
                const welcomeMessage = document.getElementById('welcome-message');
                const welcomeGreeting = document.getElementById('welcome-greeting');
                const welcomeInfo = document.getElementById('welcome-info');
                
                // Get user name from localStorage (saved from payment request) or from Google Sheets
                let userName = localStorage.getItem('userName') || '';
                
                // If no name in localStorage, try to get from payment request form
                if (!userName) {
                    const nameInput = document.getElementById('payment-name') || document.getElementById('name');
                    if (nameInput && nameInput.value.trim()) {
                        userName = nameInput.value.trim();
                        localStorage.setItem('userName', userName);
                    }
                }
                
                // If still no name, try to get from Google Sheets via payment code
                if (!userName && data.name) {
                    userName = data.name;
                    localStorage.setItem('userName', userName);
                }
                
                // Display welcome message if we have a name
                if (userName && welcomeMessage && welcomeGreeting && welcomeInfo) {
                    welcomeGreeting.textContent = `Բարև, ${userName}! 👋`;
                    welcomeInfo.textContent = 'Բարի գալուստ հարցաթերթիկներին:';
                    welcomeMessage.style.display = 'block';
                } else if (welcomeMessage) {
                    welcomeMessage.style.display = 'none';
                }
                
                // Update attempts display
                const attemptsDisplay = document.getElementById('quiz-attempts');
                if (attemptsDisplay) {
                    // Calculate total used attempts
                    loadQuizSetAttempts();
                    const totalQuizSets = 18;
                    const maxAttemptsPerSet = 3;
                    const totalMaxAttempts = totalQuizSets * maxAttemptsPerSet; // 54
                    
                    let totalUsedAttempts = 0;
                    for (let i = 1; i <= totalQuizSets; i++) {
                        const setAttempts = getQuizSetAttempts(i.toString());
                        totalUsedAttempts += setAttempts;
                    }
                    
                    const remaining = Math.max(0, totalMaxAttempts - totalUsedAttempts);
                    attemptsDisplay.innerHTML = `Առկա է <strong>18 թեստ</strong>, ունեք իրավունք անցնելու ամեն թեստը <strong>3 անգամ</strong>։<br><strong>${totalUsedAttempts}/${totalMaxAttempts} օգտագործված</strong>${remaining > 0 ? `, <strong>մնաց ${remaining}</strong>` : ''}`;
                    if (remaining === 0) {
                        attemptsDisplay.style.color = '#dc3545';
                    } else {
                        attemptsDisplay.style.color = '#28a745';
                    }
                }
                // Auto-scroll to top for better UX
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                // CRITICAL: Check if there's saved progress to restore (cross-device sync)
                // Load progress after payment verification to continue from where user left off
                setTimeout(async () => {
                    try {
                        const savedProgress = await loadQuizProgress();
                        // If no progress found, it might be because progress belongs to different device
                        // User can still start fresh (security feature: prevent multiple simultaneous sessions)
                        if (!savedProgress) {
                            // Show message that user can start fresh (progress might be on different device)
                            // Note: Payment code is valid, so user can start quiz normally
                            return;
                        }
                        
                        // Check if progress matches current payment code (case-insensitive)
                        const progressCode = (savedProgress?.paymentCode || '').toUpperCase();
                        const currentCode = (code || '').toUpperCase();
                        const paymentCodeMatches = progressCode === currentCode;
                        
                        if (savedProgress && savedProgress.gameStarted && paymentCodeMatches) {
                            // Restore progress and continue quiz from where user left off
                            currentQuestionIndex = savedProgress.currentQuestionIndex || 0;
                            score = savedProgress.score || 0;
                            userAnswers = savedProgress.userAnswers || [];
                            gameStarted = savedProgress.gameStarted;
                            if (typeof currentQuizSetIndex !== 'undefined' && savedProgress.currentQuizSetIndex >= 0) {
                                currentQuizSetIndex = savedProgress.currentQuizSetIndex;
                            }
                            
                            // Restore shuffled quiz data
                            if (savedProgress.shuffledQuizData && savedProgress.shuffledQuizData.length > 0) {
                                shuffledQuizData = [];
                                for (const questionText of savedProgress.shuffledQuizData) {
                                    const foundQuestion = quizData.find(q => q.question === questionText);
                                    if (foundQuestion) {
                                        shuffledQuizData.push(foundQuestion);
                                    }
                                }
                            }
                            
                            // Restore quiz sets if needed
                            if (typeof quizSets === 'undefined' || quizSets.length === 0) {
                                const orderedQuizData = [...quizData];
                                quizSets = [];
                                quizSetResults = [];
                                for (let i = 0; i < 17; i++) {
                                    quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
                                    quizSetResults.push({ correct: 0, wrong: 0 });
                                }
                                quizSets.push(orderedQuizData.slice(170, 175));
                                quizSetResults.push({ correct: 0, wrong: 0 });
                            }
                            
                            // Restore UI to quiz state (hide start section, show quiz)
                            if (startSection) startSection.style.display = 'none';
                            if (topicSection) topicSection.style.display = 'block';
                            if (questionSection) questionSection.style.display = 'block';
                            if (answersSection) answersSection.style.display = 'flex';
                            if (nextSection) nextSection.style.display = 'none';
                            if (resultsSection) resultsSection.style.display = 'none';
                            
                            // Load the current question
                            loadQuestion();
                            
                            // CRITICAL: Explicitly update question number display after restore
                            // Sometimes loadQuestion() runs before UI elements are fully ready
                            setTimeout(() => {
                                const questionInSet = currentQuestionIndex + 1;
                                const totalInSet = shuffledQuizData.length;
                                const questionNumberEl = document.getElementById('question-number');
                                if (questionNumberEl) {
                                    questionNumberEl.textContent = questionInSet;
                                }
                                const totalQuestionsSpan = document.getElementById('total-questions');
                                if (totalQuestionsSpan) {
                                    totalQuestionsSpan.textContent = totalInSet;
                                }
                                const quizSetNumberDisplay = document.getElementById('quiz-set-number-display');
                                if (quizSetNumberDisplay && typeof currentQuizSetIndex !== 'undefined' && currentQuizSetIndex >= 0) {
                                    if (currentQuizSetIndex < 17) {
                                        quizSetNumberDisplay.textContent = currentQuizSetIndex + 1;
                                    } else {
                                        quizSetNumberDisplay.textContent = 18;
                                    }
                                }
                                }, 100);
                            
                            progressRestored = true;
                            gameInitialized = true;
                            
                            // Start periodic session validity check (prevent multiple simultaneous sessions)
                            startSessionValidityCheck();
                            
                            // Update attempts display for current quiz set
                            if (typeof currentQuizSetIndex !== 'undefined' && currentQuizSetIndex >= 0) {
                                loadQuizSetAttempts();
                                const setAttempts = getQuizSetAttempts((currentQuizSetIndex + 1).toString());
                                const attemptsDisplay = document.getElementById('quiz-attempts');
                                if (attemptsDisplay) {
                                    loadQuizSetQuestionsUsed();
                                    const questionsUsed = getQuizSetQuestionsUsed((currentQuizSetIndex + 1).toString());
                                    if (questionsUsed > 0) {
                                        attemptsDisplay.innerHTML = `Հարցաթերթիկ #${currentQuizSetIndex + 1} - ${questionsUsed} հարց օգտագործված, <strong>${setAttempts}/3</strong> փորձ`;
                                    } else {
                                        attemptsDisplay.innerHTML = `Հարցաթերթիկ #${currentQuizSetIndex + 1} - Փորձեր: <strong>${setAttempts}/3</strong>`;
                                    }
                                    if (setAttempts >= 3) {
                                        attemptsDisplay.style.color = '#dc3545';
                                    } else {
                                        attemptsDisplay.style.color = '#28a745';
                                    }
                                }
                            }
                            return; // Don't focus on name input - user is already in quiz
                        }
                    } catch (error) {
                        }
                    
                    // If no progress to restore, focus on name input as usual
                    const userNameInput = document.getElementById('user-name');
                    if (userNameInput) {
                        userNameInput.focus();
                    }
                }, 500); // Small delay to let UI settle before restoring progress
            }, 1500);
        } else {
            paymentStatus.innerHTML = '<div class="payment-status error">❌ Վճարման կոդը սխալ է կամ արդեն օգտագործված է</div>';
            verifyPaymentBtn.disabled = false;
            verifyPaymentBtn.textContent = '✅ Ստուգել Վճարում';
        }
    } catch (error) {
        paymentStatus.innerHTML = '<div class="payment-status error">❌ Սխալ: ' + error.message + '</div>';
        verifyPaymentBtn.disabled = false;
        verifyPaymentBtn.textContent = '✅ Ստուգել Վճարում';
    }
}

// Copy to clipboard
function copyToClipboard(elementId) {
    const element = document.getElementById(elementId);
    const text = element.textContent.trim();
    
    navigator.clipboard.writeText(text).then(() => {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = '✅ Copied!';
        setTimeout(() => {
            btn.textContent = originalText;
        }, 2000);
    }).catch(err => {
        });
}

// Save quiz progress to localStorage
function saveQuizProgress() {
    try {
        // Get current browser session ID for session tracking
        const currentSessionId = getBrowserSessionId();
        
        const progress = {
            currentQuestionIndex: currentQuestionIndex,
            score: score,
            userAnswers: userAnswers,
            gameStarted: gameStarted,
            currentQuizSetIndex: typeof currentQuizSetIndex !== 'undefined' ? currentQuizSetIndex : -1,
            shuffledQuizData: shuffledQuizData && shuffledQuizData.length > 0 ? shuffledQuizData.map(q => q.question) : [],
            quizSets: typeof quizSets !== 'undefined' && quizSets.length > 0 ? quizSets.map(set => set.map(q => q.question)) : [],
            timestamp: new Date().getTime(),
            paymentCode: localStorage.getItem('paymentCode') || '',
            sessionId: currentSessionId // Track browser session to prevent multiple simultaneous sessions
        };
        localStorage.setItem('quizProgress', JSON.stringify(progress));
        // Also save to Google Apps Script for cross-device access (async, don't wait)
        saveQuizProgressToCloud(progress).catch(err => {
            });
    } catch (error) {
        }
}

// Save quiz progress to Google Apps Script (for cross-device access)
async function saveQuizProgressToCloud(progress) {
    try {
        const paymentCode = progress.paymentCode || localStorage.getItem('paymentCode') || '';
        if (!paymentCode) {
            return;
        }
        
        // Get current browser session ID for session tracking (prevent multiple simultaneous sessions)
        // This is unique per browser/tab, so different browsers on same computer have different IDs
        const currentDeviceId = getBrowserSessionId();
        // Device ID logged
        
        const callbackName = 'handleSaveQuizProgress' + Date.now();
        const params = new URLSearchParams({
            action: 'saveQuizProgress',
            paymentCode: paymentCode,
            currentQuestion: progress.currentQuestionIndex || 0,
            totalQuestions: progress.shuffledQuizData ? progress.shuffledQuizData.length : 0,
            score: progress.score || 0,
            userAnswers: JSON.stringify(progress.userAnswers || []),
            gameStarted: progress.gameStarted ? 'true' : 'false',
            quizSetNumber: progress.currentQuizSetIndex >= 0 ? (progress.currentQuizSetIndex < 17 ? progress.currentQuizSetIndex + 1 : 18) : 0,
            shuffledQuizData: JSON.stringify(progress.shuffledQuizData || []),
            deviceId: currentDeviceId, // Track device to prevent multiple simultaneous sessions
            timestamp: new Date().toISOString(),
            callback: callbackName
        });
        
        window[callbackName] = function(result) {
            // Clean up
            delete window[callbackName];
            const scripts = document.querySelectorAll('script[src*="saveQuizProgress"]');
            scripts.forEach(script => {
                if (script.parentNode) {
                    script.parentNode.removeChild(script);
                }
            });
            
            if (result && result.success) {
                // CRITICAL: Immediately check session validity after saving (to detect if another device took over)
                // This is the most important check - when progress is saved, we must verify we still own the session
                if (gameStarted) {
                    // Check multiple times with increasing delays to catch any device takeover
                    setTimeout(() => {
                        checkSessionValidity().then(isValid => {
                            if (!isValid) {
                                }
                        });
                    }, 300); // First check after 300ms
                    setTimeout(() => {
                        checkSessionValidity().then(isValid => {
                            if (!isValid) {
                                showSessionInvalidatedError('Մեկ այլ սարք օգտագործում է այս վճարման կոդը: Թեստը դադարեցված է:');
                            }
                        });
                    }, 1000); // Second check after 1 second
                }
            } else {
                }
        };
        
        const script = document.createElement('script');
        script.src = PAYMENT_WEB_APP_URL + '?' + params.toString();
        script.onerror = function() {
            delete window[callbackName];
            };
        document.body.appendChild(script);
        
        // Timeout after 10 seconds
        setTimeout(() => {
            if (window[callbackName]) {
                delete window[callbackName];
                }
        }, 10000);
    } catch (error) {
        }
}

// Get deviceId from Google Apps Script without session filtering (for session validity check)
async function getDeviceIdFromCloud(paymentCode) {
    return new Promise((resolve) => {
        const callbackName = 'handleGetDeviceId' + Date.now();
        const url = PAYMENT_WEB_APP_URL + '?action=getQuizProgress&paymentCode=' + encodeURIComponent(paymentCode) + '&callback=' + callbackName;
        
        window[callbackName] = function(result) {
            // Clean up
            delete window[callbackName];
            const scripts = document.querySelectorAll('script[src*="getQuizProgress"]');
            scripts.forEach(script => {
                if (script.parentNode) {
                    script.parentNode.removeChild(script);
                }
            });
            
            if (result && result.success && result.progress) {
                const deviceId = result.progress.deviceId || '';
                resolve(deviceId);
            } else {
                resolve('');
            }
        };
        
        const script = document.createElement('script');
        script.src = url;
        script.onerror = function() {
            delete window[callbackName];
            resolve(''); // On error, return empty
        };
        document.head.appendChild(script);
        
        // Timeout after 10 seconds
        setTimeout(() => {
            if (window[callbackName]) {
                delete window[callbackName];
                resolve(''); // On timeout, return empty
            }
        }, 10000);
    });
}

// Check if current session is still valid (not replaced by another browser)
// CRITICAL: This function is called frequently to detect device takeover
async function checkSessionValidity() {
    try {
        const paymentCode = localStorage.getItem('paymentCode');
        if (!paymentCode || !gameStarted) {
            return true; // No active session, nothing to check
        }
        
        // SECURITY: First check if payment code still exists in Google Sheets
        // If code was deleted, immediately invalidate session
        const codeExists = await verifyPaymentCodeQuick(paymentCode);
        if (!codeExists) {
            showSessionInvalidatedError('Վճարման կոդը ջնջված է: Թեստը դադարեցված է');
            return false;
        }
        
        const currentSessionId = getBrowserSessionId();
        
        // Get deviceId directly from cloud (without filtering) to check if it matches
        const savedDeviceId = await getDeviceIdFromCloud(paymentCode);
        
        // Check if session matches
        if (savedDeviceId && savedDeviceId.length > 0) {
            // CRITICAL: If deviceId exists and doesn't match, session is INVALIDATED
            if (savedDeviceId !== currentSessionId) {
                // Another browser/device has taken over this payment code
                // Immediately show error and disable quiz
                showSessionInvalidatedError('Մեկ այլ սարք օգտագործում է այս վճարման կոդը: Թեստը դադարեցված է:');
                stopSessionValidityCheck(); // Stop checking since session is invalid
                
                // Also clear local progress to prevent confusion
                localStorage.removeItem('quizProgress');
                
                return false;
            } else {
                // DeviceId matches - session is still valid
                }
        } else {
            // No deviceId in cloud - this might be a new session or progress hasn't been saved yet
            // Don't invalidate, but log for debugging
        }
        
        return true;
    } catch (error) {
        // On error, assume session is still valid (don't block user)
        return true;
    }
}

// Show error message when session is invalidated by another browser or payment code is deleted
function showSessionInvalidatedError(customMessage) {
    // Check if error already shown to prevent duplicate
    const existingError = document.getElementById('session-invalidated-error');
    if (existingError) {
        return;
    }
    
    // Disable quiz interaction
    gameStarted = false;
    
    // Clear all payment-related data
    localStorage.removeItem('paymentToken');
    localStorage.removeItem('paymentTimestamp');
    localStorage.removeItem('paymentIP');
    localStorage.removeItem('paymentDevice');
    localStorage.removeItem('paymentCode');
    localStorage.removeItem('quizProgress');
    
    // Hide quiz sections
    if (questionSection) questionSection.style.display = 'none';
    if (answersSection) answersSection.style.display = 'none';
    if (nextSection) nextSection.style.display = 'none';
    if (resultsSection) resultsSection.style.display = 'none';
    if (startSection) startSection.style.display = 'none';
    
    // Show payment section again
    if (paymentSection) paymentSection.style.display = 'block';
    
    // Default message or custom message
    const message = customMessage || 'Ուրիշ օգտատեր մուտք է գործել նույն վճարման կոդով:<br>Խնդրում ենք թարմացնել էջը կամ օգտագործել նույն browser-ը:';
    
    // Show error message
    const errorMessage = document.createElement('div');
    errorMessage.id = 'session-invalidated-error';
    errorMessage.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #dc3545; color: white; padding: 30px; border-radius: 10px; z-index: 10000; max-width: 500px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);';
    errorMessage.innerHTML = `
        <h2 style="margin-top: 0; color: white;">⚠️ Թեստը դադարեցված է</h2>
        <p style="font-size: 16px; line-height: 1.6;">
            ${message}
        </p>
        <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: white; color: #dc3545; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">
            🔄 Թարմացնել Էջը
        </button>
    `;
    
    document.body.appendChild(errorMessage);
    
    // Also show in payment status area
    if (paymentStatus) {
        paymentStatus.innerHTML = '<div class="payment-status error" style="background: #dc3545; color: white; padding: 15px; border-radius: 5px; margin: 20px 0;">⚠️ ' + message.replace('<br>', ' ') + '</div>';
    }
}

// Start periodic session validity check (every 0.5 seconds for very fast detection)
let sessionCheckInterval = null;
function startSessionValidityCheck() {
    if (sessionCheckInterval) {
        clearInterval(sessionCheckInterval);
    }
    
    // Check immediately first time
    if (gameStarted) {
        checkSessionValidity().then(isValid => {
            if (!isValid) {
                // Session invalidated, stop checking
                if (sessionCheckInterval) {
                    clearInterval(sessionCheckInterval);
                    sessionCheckInterval = null;
                }
            }
        });
    }
    
    sessionCheckInterval = setInterval(async () => {
        if (gameStarted) {
            const isValid = await checkSessionValidity();
            if (!isValid) {
                // Session invalidated, stop checking
                if (sessionCheckInterval) {
                    clearInterval(sessionCheckInterval);
                    sessionCheckInterval = null;
                }
            }
        }
    }, 500); // Check every 0.5 seconds for very fast detection when new session starts
}

// Stop session validity check
function stopSessionValidityCheck() {
    if (sessionCheckInterval) {
        clearInterval(sessionCheckInterval);
        sessionCheckInterval = null;
    }
}

// Load quiz progress from localStorage and Google Apps Script
async function loadQuizProgress() {
    try {
        // First, try to load from localStorage (faster)
        const savedProgress = localStorage.getItem('quizProgress');
        if (savedProgress) {
            const progress = JSON.parse(savedProgress);
            // Check if progress is recent (within 24 hours)
            const hoursSinceSave = (new Date().getTime() - progress.timestamp) / (1000 * 60 * 60);
            if (hoursSinceSave < 24) {
                // Check if payment code matches
                const currentPaymentCode = localStorage.getItem('paymentCode');
                if (currentPaymentCode && progress.paymentCode === currentPaymentCode) {
                    // SECURITY: Check if progress belongs to current browser session
                    // Prevent multiple simultaneous sessions with same payment code
                    const savedSessionId = progress.sessionId || '';
                    const currentSessionId = getBrowserSessionId();
                    
                    // Check if session matches
                    if (savedSessionId && currentSessionId && savedSessionId !== currentSessionId) {
                        // Clear old progress from different session
                        localStorage.removeItem('quizProgress');
                        // Don't return progress - this prevents multiple simultaneous sessions
                        return null;
                    }
                    
                    return progress;
                }
            } else {
                // Progress is too old, clear it
                localStorage.removeItem('quizProgress');
            }
        }
        
        // If no localStorage progress, try to load from Google Apps Script (for cross-device access)
        const currentPaymentCode = localStorage.getItem('paymentCode');
        if (currentPaymentCode) {
            try {
                const cloudProgress = await loadQuizProgressFromCloud(currentPaymentCode);
                if (cloudProgress) {
                    // Also save to localStorage for faster access next time
                    localStorage.setItem('quizProgress', JSON.stringify(cloudProgress));
                    return cloudProgress;
                } else {
                    }
            } catch (error) {
                }
        } else {
            }
        
        return null;
    } catch (error) {
        return null;
    }
}

// Load quiz progress from Google Apps Script (for cross-device access)
async function loadQuizProgressFromCloud(paymentCode) {
    return new Promise((resolve, reject) => {
        const callbackName = 'handleGetQuizProgress' + Date.now();
        const url = PAYMENT_WEB_APP_URL + '?action=getQuizProgress&paymentCode=' + encodeURIComponent(paymentCode) + '&callback=' + callbackName;
        
        window[callbackName] = function(result) {
            // Clean up
            delete window[callbackName];
            const scripts = document.querySelectorAll('script[src*="getQuizProgress"]');
            scripts.forEach(script => {
                if (script.parentNode) {
                    script.parentNode.removeChild(script);
                }
            });
            
            if (result && result.success && result.progress) {
                // SECURITY: Check if progress belongs to current browser session
                // Prevent multiple simultaneous sessions with same payment code
                const savedDeviceId = result.progress.deviceId || '';
                const currentDeviceId = getBrowserSessionId(); // Unique per browser/tab
                
                // Check if device matches
                
                if (savedDeviceId && currentDeviceId && savedDeviceId !== currentDeviceId) {
                    // Device mismatch detected
                    // Don't restore progress - this prevents multiple simultaneous sessions
                    resolve(null);
                    return;
                }
                
                // Convert cloud progress to local format
                let userAnswers = [];
                let shuffledQuizData = [];
                
                try {
                    if (typeof result.progress.userAnswers === 'string') {
                        userAnswers = JSON.parse(result.progress.userAnswers);
                    } else if (Array.isArray(result.progress.userAnswers)) {
                        userAnswers = result.progress.userAnswers;
                    } else {
                        userAnswers = [];
                    }
                } catch (e) {
                    userAnswers = [];
                }
                
                try {
                    if (typeof result.progress.shuffledQuizData === 'string') {
                        shuffledQuizData = JSON.parse(result.progress.shuffledQuizData);
                    } else if (Array.isArray(result.progress.shuffledQuizData)) {
                        shuffledQuizData = result.progress.shuffledQuizData;
                    } else {
                        shuffledQuizData = [];
                    }
                } catch (e) {
                    shuffledQuizData = [];
                }
                
                // Parse gameStarted - handle both boolean and string ('true'/'false')
                let gameStarted = true; // default
                if (result.progress.gameStarted !== undefined) {
                    if (typeof result.progress.gameStarted === 'string') {
                        gameStarted = result.progress.gameStarted.toLowerCase() === 'true';
                    } else {
                        gameStarted = Boolean(result.progress.gameStarted);
                    }
                }
                
                // CRITICAL: If we have a question index > 0, game MUST have started
                const currentQuestion = result.progress.currentQuestion || 0;
                if (currentQuestion > 0) {
                    gameStarted = true;
                }
                
                // If session ID matches, use current session ID (progress belongs to this session)
                // If session ID doesn't match, progress was rejected above, so we won't reach here
                const currentSessionId = getBrowserSessionId();
                // savedDeviceId already declared above (line 3633)
                
                const progress = {
                    currentQuestionIndex: result.progress.currentQuestion || 0,
                    score: result.progress.score || 0,
                    userAnswers: userAnswers,
                    gameStarted: gameStarted,
                    currentQuizSetIndex: result.progress.quizSetNumber ? (result.progress.quizSetNumber <= 17 ? result.progress.quizSetNumber - 1 : 17) : -1,
                    shuffledQuizData: shuffledQuizData,
                    timestamp: result.progress.timestamp ? new Date(result.progress.timestamp).getTime() : new Date().getTime(),
                    paymentCode: paymentCode,
                    sessionId: currentSessionId, // Update to current session ID (progress belongs to this session now)
                    deviceId: savedDeviceId // Keep original deviceId from cloud for session validity checking
                };
                resolve(progress);
            } else {
                resolve(null);
            }
        };
        
        const script = document.createElement('script');
        script.src = url;
        script.onerror = function() {
            delete window[callbackName];
            resolve(null); // Don't reject, just return null
        };
        document.body.appendChild(script);
        
        // Timeout after 10 seconds
        setTimeout(() => {
            if (window[callbackName]) {
                delete window[callbackName];
                resolve(null);
            }
        }, 10000);
    });
}

// Track quiz progress in Google Apps Script
async function trackQuizProgress(eventType, quizSetNumber) {
    try {
        const paymentCode = localStorage.getItem('paymentCode') || '';
        const userName = document.getElementById('user-name')?.value.trim() || 'Անանուն';
        const currentQuestion = currentQuestionIndex || 0;
        const totalQuestions = shuffledQuizData.length || 0;
        const currentScore = score || 0;
        
        if (!paymentCode) {
            return;
        }
        
        // Send to Google Apps Script using JSONP (more reliable than POST with no-cors)
        const callbackName = 'handleTrackQuizProgress' + Date.now();
        const params = new URLSearchParams({
            action: 'trackQuizProgress',
            paymentCode: paymentCode,
            eventType: eventType,
            userName: userName,
            quizSetNumber: quizSetNumber || 0,
            currentQuestion: currentQuestion,
            totalQuestions: totalQuestions,
            score: currentScore,
            timestamp: new Date().toISOString(),
            callback: callbackName
        });
        
        return new Promise((resolve, reject) => {
            window[callbackName] = function(result) {
                // Clean up
                delete window[callbackName];
                const scripts = document.querySelectorAll('script[src*="trackQuizProgress"]');
                scripts.forEach(script => {
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                });
                
                if (result && result.success) {
                    resolve(result);
                } else {
                    resolve(result); // Don't reject, just log error
                }
            };
            
            const script = document.createElement('script');
            script.src = PAYMENT_WEB_APP_URL + '?' + params.toString();
            script.onerror = function() {
                delete window[callbackName];
                resolve({ success: false, error: 'Script load error' }); // Don't reject
            };
            document.body.appendChild(script);
            
            // Timeout after 10 seconds
            setTimeout(() => {
                if (window[callbackName]) {
                    delete window[callbackName];
                    resolve({ success: false, error: 'Request timeout' }); // Don't reject
                }
            }, 10000);
        });
    } catch (error) {
        }
}

// Flag to prevent multiple initializations
let gameInitialized = false;
let progressRestored = false;
let initializationInProgress = false; // Prevent concurrent initialization attempts

// Initialize game
async function initGame() {
    // CRITICAL: Prevent multiple calls to initGame() - check ALL possible flags
    if (initializationInProgress) {
        return;
    }
    
    if (gameInitialized && pageInitialized) {
        return;
    }
    
    // Check window.name first (most reliable)
    if (window.name && window.name.includes('quizPageInitialized')) {
        return;
    }
    
    // Mark as in progress IMMEDIATELY to prevent race conditions
    initializationInProgress = true;
    gameInitialized = true;
    pageInitialized = true;
    window.name = 'quizPageInitialized_' + Date.now();
    try {
        sessionStorage.setItem('pageInitialized', 'true');
        localStorage.setItem('pageInitialized', 'true');
    } catch (e) {
        // sessionStorage/localStorage not available
    }
    
    // CRITICAL: Check payment status FIRST - if user has active payment, restore UI immediately
    const paymentCode = localStorage.getItem('paymentCode');
    const paymentToken = localStorage.getItem('paymentToken');
    if (paymentCode && paymentToken) {
        // User has active payment - check if we should restore UI
        const paymentStatus = await checkPaymentStatus();
        if (paymentStatus.paid) {
            // Payment is valid - restore UI to start section (don't show payment form)
            if (paymentSection) paymentSection.style.display = 'none';
            if (startSection) startSection.style.display = 'block';
            // Check if we have saved progress to continue from
            const savedProgress = await loadQuizProgress();
            if (savedProgress && savedProgress.gameStarted && savedProgress.paymentCode === paymentCode) {
                // Restore progress and continue quiz
                currentQuestionIndex = savedProgress.currentQuestionIndex || 0;
                score = savedProgress.score || 0;
                userAnswers = savedProgress.userAnswers || [];
                gameStarted = savedProgress.gameStarted;
                if (typeof currentQuizSetIndex !== 'undefined' && savedProgress.currentQuizSetIndex >= 0) {
                    currentQuizSetIndex = savedProgress.currentQuizSetIndex;
                }
                
                // Restore shuffled quiz data
                if (savedProgress.shuffledQuizData && savedProgress.shuffledQuizData.length > 0) {
                    shuffledQuizData = [];
                    for (const questionText of savedProgress.shuffledQuizData) {
                        const foundQuestion = quizData.find(q => q.question === questionText);
                        if (foundQuestion) {
                            shuffledQuizData.push(foundQuestion);
                        }
                    }
                }
                
                // Restore quiz sets if needed
                if (typeof quizSets === 'undefined' || quizSets.length === 0) {
                    const orderedQuizData = [...quizData];
                    quizSets = [];
                    quizSetResults = [];
                    for (let i = 0; i < 17; i++) {
                        quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
                        quizSetResults.push({ correct: 0, wrong: 0 });
                    }
                    quizSets.push(orderedQuizData.slice(170, 175));
                    quizSetResults.push({ correct: 0, wrong: 0 });
                }
                
                // Restore UI to quiz state
                if (paymentSection) paymentSection.style.display = 'none';
                if (startSection) startSection.style.display = 'none';
                if (topicSection) topicSection.style.display = 'block';
                if (questionSection) questionSection.style.display = 'block';
                if (answersSection) answersSection.style.display = 'flex';
                if (nextSection) nextSection.style.display = 'none';
                if (resultsSection) resultsSection.style.display = 'none';
                
                // Load the current question
                loadQuestion();
                
                progressRestored = true;
                gameInitialized = true;
                pageInitialized = true;
                window.name = 'quizPageInitialized_' + Date.now();
                try {
                    sessionStorage.setItem('pageInitialized', 'true');
                    localStorage.setItem('pageInitialized', 'true');
                } catch (e) {}
                
                return; // Early return - don't do heavy operations
            }
        }
    }
    
    // CRITICAL: Check if page was already initialized (multiple methods - MAXIMUM RELIABILITY)
    // Check window.name first (most reliable)
    if (window.name && window.name.includes('quizPageInitialized')) {
        return;
    }
    
    // Check sessionStorage AND localStorage (backup)
    try {
        if (sessionStorage.getItem('pageInitialized') === 'true' || localStorage.getItem('pageInitialized') === 'true') {
            return;
        }
    } catch (e) {
        // sessionStorage/localStorage not available, continue
    }
    
    // Check pageUnloading flag (BOTH sessionStorage AND localStorage)
    try {
        if (sessionStorage.getItem('pageUnloading') === 'true' || localStorage.getItem('pageUnloading') === 'true') {
            return;
        }
    } catch (e) {
        // sessionStorage/localStorage not available, continue
    }
    
    // Check variable
    if (pageInitialized) {
        return;
    }
    
    // If progress was already restored by pageshow, skip heavy operations
    if (progressRestored && gameInitialized) {
        return;
    }
    
    // Don't reset if we're restoring from pageshow (minimize/maximize)
    if (isRestoringFromPageshow) {
        return;
    }
    
    // Don't reset if page was just hidden and is now visible again (minimize/maximize)
    // Check if we have saved progress in localStorage (fast check)
    // Note: paymentCode is already declared at the start of initGame()
    if (paymentCode) {
        const localProgress = localStorage.getItem('quizProgress');
        if (localProgress) {
            try {
                const progress = JSON.parse(localProgress);
                const hoursSinceSave = (new Date().getTime() - progress.timestamp) / (1000 * 60 * 60);
                // If we have recent progress (within 24 hours) and game was started, don't reset
                if (hoursSinceSave < 24 && progress.gameStarted && progress.paymentCode === paymentCode) {
                    return;
                }
            } catch (e) {
                // Continue with normal init if parsing fails
            }
        }
    }
    
    // Check for saved progress first (from localStorage and Google Apps Script)
    const savedProgress = await loadQuizProgress();
    
    if (savedProgress && savedProgress.gameStarted) {
        progressRestored = true;
        // Restore progress
        currentQuestionIndex = savedProgress.currentQuestionIndex || 0;
        score = savedProgress.score || 0;
        userAnswers = savedProgress.userAnswers || [];
        gameStarted = savedProgress.gameStarted;
        if (typeof currentQuizSetIndex !== 'undefined' && savedProgress.currentQuizSetIndex >= 0) {
            currentQuizSetIndex = savedProgress.currentQuizSetIndex;
        }
        
        // Check payment status
        const paymentStatus = await checkPaymentStatus();
        
        // SECURITY: Also verify that payment code still exists in Google Sheets
        // This prevents access if code was deleted from admin panel
        if (paymentStatus.paid) {
            const currentPaymentCode = localStorage.getItem('paymentCode') || '';
            if (currentPaymentCode) {
                try {
                    // Quick verification: check if code exists in Google Sheets
                    const codeStillValid = await verifyPaymentCodeQuick(currentPaymentCode);
                    if (!codeStillValid) {
                        // Clear all payment-related data
                        localStorage.removeItem('paymentToken');
                        localStorage.removeItem('paymentTimestamp');
                        localStorage.removeItem('paymentIP');
                        localStorage.removeItem('paymentDevice');
                        localStorage.removeItem('paymentCode');
                        localStorage.removeItem('quizProgress');
                        // Show payment section again
                        if (paymentSection) paymentSection.style.display = 'block';
                        if (startSection) startSection.style.display = 'none';
                        if (quizSection) quizSection.style.display = 'none';
                        const paymentStatusEl = document.getElementById('payment-status');
                        if (paymentStatusEl) {
                            paymentStatusEl.innerHTML = '<div class="payment-status error">❌ Վճարման կոդը չի գտնվել կամ անվավեր է</div>';
                        }
                        return; // Don't restore progress
                    }
                } catch (error) {
                    // On error, allow access (fail open for better UX, but log the error)
                }
            }
        }
        
        if (paymentStatus.paid) {
            // User has paid and has saved progress, show continue option
            if (paymentSection) paymentSection.style.display = 'none';
            if (startSection) startSection.style.display = 'block';
            
            // Auto-continue if progress exists (no confirmation needed)
            // Restore quiz state
            if (savedProgress.shuffledQuizData && savedProgress.shuffledQuizData.length > 0) {
                // Restore shuffled quiz data by finding questions
                shuffledQuizData = [];
                for (const questionText of savedProgress.shuffledQuizData) {
                    const foundQuestion = quizData.find(q => q.question === questionText);
                    if (foundQuestion) {
                        shuffledQuizData.push(foundQuestion);
                    }
                }
            }
            
            // If we have quiz sets, restore them
            if (typeof quizSets !== 'undefined' && quizSets.length > 0 && currentQuizSetIndex >= 0) {
                // Quiz sets already exist, just restore current state
            } else {
                // Need to recreate quiz sets
                const orderedQuizData = [...quizData];
                quizSets = [];
                quizSetResults = [];
                for (let i = 0; i < 17; i++) {
                    quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
                    quizSetResults.push({ correct: 0, wrong: 0 });
                }
                quizSets.push(orderedQuizData.slice(170, 175));
                quizSetResults.push({ correct: 0, wrong: 0 });
            }
            
            // Restore UI to quiz state
            if (paymentSection) paymentSection.style.display = 'none';
            if (startSection) startSection.style.display = 'none';
            if (topicSection) topicSection.style.display = 'block';
            if (questionSection) questionSection.style.display = 'block';
            if (answersSection) answersSection.style.display = 'flex';
            if (nextSection) nextSection.style.display = 'none';
            if (resultsSection) resultsSection.style.display = 'none';
            
            // Track quiz continue
            const quizSetNumber = savedProgress.currentQuizSetIndex >= 0 ? 
                (savedProgress.currentQuizSetIndex < 17 ? savedProgress.currentQuizSetIndex + 1 : 18) : 0;
            trackQuizProgress('continue', quizSetNumber);
            
            // Load the current question
            loadQuestion();
            
            gameInitialized = true;
            pageInitialized = true; // Mark page as initialized to prevent re-init
            window.name = 'quizPageInitialized_' + Date.now();
            try {
                sessionStorage.setItem('pageInitialized', 'true');
                localStorage.setItem('pageInitialized', 'true'); // Also set in localStorage as backup
            } catch (e) {}
            return; // Early return - don't do heavy operations
        }
    }
    
    // No saved progress or user chose to start fresh
    // CRITICAL: Don't reset if payment code and token exist (user was in middle of quiz)
    // Note: paymentCode and paymentToken are already declared at the start of initGame()
    const hasPayment = paymentCode && paymentToken;
    
    if (!savedProgress || !savedProgress.gameStarted) {
        // Only reset if progress wasn't already restored AND user doesn't have active payment
        if (!progressRestored && !hasPayment) {
            currentQuestionIndex = 0;
            score = 0;
            userAnswers = [];
            gameStarted = false;
        } else if (hasPayment) {
            // User has payment but no saved progress - don't reset, let them continue
            }
    }
    
    // Only do heavy operations if progress wasn't already restored
    if (!progressRestored) {
        // Load quiz set attempts from localStorage first (faster)
        loadQuizSetAttempts();
        loadQuizSetQuestionsUsed();
        // Also try to load from cloud to sync (in case localStorage was cleared)
        loadQuizSetAttemptsFromCloud().then(cloudAttempts => {
            if (cloudAttempts) {
                }
        });
        
        // Check payment status (fast localStorage check first)
        const paymentStatus = await checkPaymentStatus();
        
        if (paymentStatus.paid) {
            // User has paid, hide payment section and show quiz
            if (paymentSection) paymentSection.style.display = 'none';
            if (startSection) startSection.style.display = 'block';
        } else {
            // User hasn't paid
            // IMPORTANT: Don't force payment screen if user is already in quiz (e.g., after restore)
            if (!gameStarted) {
                if (paymentSection) paymentSection.style.display = 'block';
                if (startSection) startSection.style.display = 'none';
            }
        }
        
        if (topicSection) topicSection.style.display = 'none';
        if (questionSection) questionSection.style.display = 'none';
        if (answersSection) answersSection.style.display = 'none';
        if (nextSection) nextSection.style.display = 'none';
        if (resultsSection) resultsSection.style.display = 'none';
    }
    
    // Only update UI if progress wasn't already restored
    if (!progressRestored) {
        if (totalQuestions) totalQuestions.textContent = quizData.length;
        
        // Update attempts display if element exists
        // Calculate remaining attempts based on quiz sets (18 sets * 3 attempts each = 54 total)
        const attemptsDisplay = document.getElementById('quiz-attempts');
        if (attemptsDisplay) {
            loadQuizSetAttempts();
            
            // Calculate total remaining attempts across all quiz sets
            const totalQuizSets = 18;
            const maxAttemptsPerSet = 3;
            const totalMaxAttempts = totalQuizSets * maxAttemptsPerSet; // 54
            
            let totalUsedAttempts = 0;
            for (let i = 1; i <= totalQuizSets; i++) {
                const setAttempts = getQuizSetAttempts(i.toString());
                totalUsedAttempts += setAttempts;
            }
            
            const remaining = Math.max(0, totalMaxAttempts - totalUsedAttempts);
            // Display as: Used/Total (e.g., 27/54 or 54/54)
            attemptsDisplay.innerHTML = `Առկա է <strong>18 թեստ</strong>, ունեք իրավունք անցնելու ամեն թեստը <strong>3 անգամ</strong>։<br><strong>${totalUsedAttempts}/${totalMaxAttempts} օգտագործված</strong>${remaining > 0 ? `, <strong>մնաց ${remaining}</strong>` : ''}`;
            if (remaining === 0) {
                attemptsDisplay.style.color = '#dc3545';
            } else {
                attemptsDisplay.style.color = '#28a745';
            }
        }
        
        // Update attempts header display (use current quiz set attempts if available)
        let attempts;
        if (typeof currentQuizSetIndex !== 'undefined' && currentQuizSetIndex >= 0) {
            const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
            attempts = getQuizSetAttempts(quizSetNumber.toString());
        } else {
            attempts = getQuizAttempts();
        }
        updateAttemptsDisplay(attempts);
        
        if (scoreDisplay) scoreDisplay.textContent = score;
    }
    
    gameInitialized = true;
    pageInitialized = true; // Mark page as initialized to prevent re-init
    window.name = 'quizPageInitialized_' + Date.now();
    try {
        sessionStorage.setItem('pageInitialized', 'true');
        localStorage.setItem('pageInitialized', 'true'); // Also set in localStorage as backup
    } catch (e) {}
    
    // CRITICAL: Reset initializationInProgress flag after initGame completes
    // This allows re-initialization if needed (e.g., after page reload)
    // But prevents concurrent initialization attempts
    initializationInProgress = false;
}

// Start the quiz
async function startQuiz() {
    // Check payment status before starting (with security checks)
    const paymentStatus = await checkPaymentStatus();
    
    if (!paymentStatus.paid) {
        alert('⚠️ Խնդրում ենք վճարել հարցաթերթիկները մուտք գործելու համար');
        if (paymentSection) paymentSection.style.display = 'block';
        if (startSection) startSection.style.display = 'none';
        return;
    }
    
    // CRITICAL: Load attempts from cloud before starting quiz
    // This ensures that attempts from other browsers are visible
    await loadQuizSetAttemptsFromCloud();
    // Load quiz set attempts from localStorage first
    loadQuizSetAttempts();
    
    // Check if all quiz sets are exhausted (each completed 3 times)
    // Don't check global attempts - check individual quiz set attempts
    // All 18 quiz sets should be available (each can be done 3 times)
    // Only prevent if ALL quiz sets are exhausted (all 18 sets completed 3 times each)
    
    // Get user name if available
    const nameInput = document.getElementById('user-name');
    if (nameInput) {
        userName = nameInput.value.trim() || 'Անանուն';
    }
    
    // Load quiz set attempts from localStorage
    loadQuizSetAttempts();
    
    // Don't shuffle - keep questions in same order for consistent quiz sets
    // Each quiz set will always have the same questions
    const orderedQuizData = [...quizData]; // Use original order, no shuffle
    
    // Divide into 18 quiz sets: 17 sets of 10 + 1 set of 5 (18th test) = 175 questions
    quizSets = [];
    quizSetResults = [];
    for (let i = 0; i < 17; i++) {
        quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
        quizSetResults.push({ correct: 0, wrong: 0 });
    }
    // Last set (18th test) with 5 questions
    quizSets.push(orderedQuizData.slice(170, 175));
    quizSetResults.push({ correct: 0, wrong: 0 });
    
    // Find first available (not exhausted) quiz set
    currentQuizSetIndex = findNextAvailableQuizSet();
    if (currentQuizSetIndex === -1) {
        alert('⚠️ Բոլոր հարցաթերթիկները սպառված են (3 անգամ անցել):\nՆոր վճարում կատարեք, որպեսզի կարողանաք նորից անցնել հարցաթերթիկները:');
        return;
    }
    
    shuffledQuizData = [...quizSets[currentQuizSetIndex]]; // Start with first available set
    
    // Reset game state
    currentQuestionIndex = 0;
    score = 0;
    userAnswers = [];
    
    gameStarted = true;
    if (startSection) startSection.style.display = 'none';
    if (paymentSection) paymentSection.style.display = 'none';
    if (topicSection) topicSection.style.display = 'block';
    if (questionSection) questionSection.style.display = 'block';
    if (answersSection) answersSection.style.display = 'flex';
    if (resultsSection) resultsSection.style.display = 'none';
    
    // Save progress when quiz starts
    saveQuizProgress();
    
    // CRITICAL: Save deviceId to cloud IMMEDIATELY when quiz starts
    // This ensures that if another session starts with same payment code, it will be detected quickly
    const paymentCode = localStorage.getItem('paymentCode') || '';
    if (paymentCode) {
        const currentDeviceId = getBrowserSessionId();
        // Save progress immediately to update deviceId in cloud
        const progress = {
            paymentCode: paymentCode,
            currentQuestionIndex: 0,
            currentQuizSetIndex: currentQuizSetIndex,
            score: 0,
            userAnswers: [],
            gameStarted: true,
            shuffledQuizData: [],
            deviceId: currentDeviceId,
            sessionId: currentDeviceId,
            timestamp: new Date().getTime()
        };
        saveQuizProgressToCloud(progress).catch(err => {
            });
    }
    
    // Start periodic session validity check (prevent multiple simultaneous sessions)
    startSessionValidityCheck();
    
    // Track quiz start in Google Apps Script
    const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
    trackQuizProgress('start', quizSetNumber);
    
    // Update attempts display for current quiz set after sections are visible
    setTimeout(() => {
        const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
        const quizSetAttempts = getQuizSetAttempts(quizSetNumber.toString());
        updateAttemptsDisplay(quizSetAttempts);
    }, 100);
    
    loadQuestion();
}

// Update attempts display in header (based on current quiz set)
function updateAttemptsDisplay(attempts) {
    // IMPORTANT: Always load attempts from localStorage first to ensure we have the latest data
    loadQuizSetAttempts();
    
    // If attempts is not provided, get it from current quiz set
    if (attempts === undefined) {
        const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
        attempts = getQuizSetAttempts(quizSetNumber.toString());
    }
    
    // Get questions used for current quiz set
    loadQuizSetQuestionsUsed();
    const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
    const questionsUsed = getQuizSetQuestionsUsed(quizSetNumber.toString());
    
    const attemptsHeaderText = document.getElementById('quiz-attempts-header-text');
    if (attemptsHeaderText) {
        if (questionsUsed > 0) {
            attemptsHeaderText.textContent = `${questionsUsed} հարց օգտագործված, ${attempts}/3 փորձ`;
        } else {
            attemptsHeaderText.textContent = `3-ից ${attempts} սպառված`;
        }
        if (attempts >= 3) {
            attemptsHeaderText.style.color = '#dc3545';
        } else if (attempts >= 2) {
            attemptsHeaderText.style.color = '#ffc107';
        } else {
            attemptsHeaderText.style.color = '#28a745';
        }
        } else {
        }
}

// Repeat quiz with same questions (same test attempt, no new attempt)
function repeatQuiz() {
    // Load quiz set attempts from localStorage
    loadQuizSetAttempts();
    
    // Don't shuffle - keep questions in same order for consistent quiz sets
    const orderedQuizData = [...quizData]; // Use original order, no shuffle
    
    // Divide into 18 quiz sets: 17 sets of 10 + 1 set of 5 (18th test) = 175 questions
    quizSets = [];
    quizSetResults = [];
    for (let i = 0; i < 17; i++) {
        quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
        quizSetResults.push({ correct: 0, wrong: 0 });
    }
    // Last set (18th test) with 5 questions
    quizSets.push(orderedQuizData.slice(170, 175));
    quizSetResults.push({ correct: 0, wrong: 0 });
    
    // Find first available (not exhausted) quiz set
    currentQuizSetIndex = findNextAvailableQuizSet();
    if (currentQuizSetIndex === -1) {
        alert('⚠️ Բոլոր հարցաթերթիկները սպառված են (3 անգամ անցել):\nՆոր վճարում կատարեք, որպեսզի կարողանաք նորից անցնել հարցաթերթիկները:');
        return;
    }
    
    shuffledQuizData = [...quizSets[currentQuizSetIndex]]; // Start with first available set
    
    // Reset game state
    currentQuestionIndex = 0;
    score = 0;
    userAnswers = [];
    
    // Show quiz sections
    if (resultsSection) resultsSection.style.display = 'none';
    if (topicSection) topicSection.style.display = 'block';
    if (questionSection) questionSection.style.display = 'block';
    if (answersSection) answersSection.style.display = 'flex';
    if (nextSection) nextSection.style.display = 'none';
    
    // Update attempts display for current quiz set after sections are visible
    setTimeout(() => {
        const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
        const quizSetAttempts = getQuizSetAttempts(quizSetNumber.toString());
        updateAttemptsDisplay(quizSetAttempts);
    }, 100);
    
    loadQuestion();
}

// Change quiz with new random questions (same test attempt, no new attempt)
function changeQuiz() {
    // Load quiz set attempts from localStorage
    loadQuizSetAttempts();
    
    // Don't shuffle - keep questions in same order for consistent quiz sets
    const orderedQuizData = [...quizData]; // Use original order, no shuffle
    
    // Divide into 18 quiz sets: 17 sets of 10 + 1 set of 5 (18th test) = 175 questions
    quizSets = [];
    quizSetResults = [];
    for (let i = 0; i < 17; i++) {
        quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
        quizSetResults.push({ correct: 0, wrong: 0 });
    }
    // Last set (18th test) with 5 questions
    quizSets.push(orderedQuizData.slice(170, 175));
    quizSetResults.push({ correct: 0, wrong: 0 });
    
    // Find first available (not exhausted) quiz set
    currentQuizSetIndex = findNextAvailableQuizSet();
    if (currentQuizSetIndex === -1) {
        alert('⚠️ Բոլոր հարցաթերթիկները սպառված են (3 անգամ անցել):\nՆոր վճարում կատարեք, որպեսզի կարողանաք նորից անցնել հարցաթերթիկները:');
        return;
    }
    
    shuffledQuizData = [...quizSets[currentQuizSetIndex]]; // Start with first available set
    
    // Reset game state
    currentQuestionIndex = 0;
    score = 0;
    userAnswers = [];
    
    // Show quiz sections
    if (resultsSection) resultsSection.style.display = 'none';
    if (topicSection) topicSection.style.display = 'block';
    if (questionSection) questionSection.style.display = 'block';
    if (answersSection) answersSection.style.display = 'flex';
    if (nextSection) nextSection.style.display = 'none';
    
    // Update attempts display for current quiz set after sections are visible
    setTimeout(() => {
        const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
        const quizSetAttempts = getQuizSetAttempts(quizSetNumber.toString());
        updateAttemptsDisplay(quizSetAttempts);
    }, 100);
    
    loadQuestion();
}

// Load current question
function loadQuestion() {
    // Check if current quiz set is finished
    if (currentQuestionIndex >= shuffledQuizData.length) {
        showQuizSetResults();
        return;
    }
    
    // Save progress when question is loaded
    saveQuizProgress();
    
    // Update attempts display when question is loaded (section is visible)
    // Use current quiz set attempts instead of global attempts
    // IMPORTANT: Load attempts from localStorage first to ensure we have the latest data
    loadQuizSetAttempts();
    const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
    const attempts = getQuizSetAttempts(quizSetNumber.toString());
    updateAttemptsDisplay(attempts);
    
    const question = shuffledQuizData[currentQuestionIndex];
    
    // Update question number (show question number within set: 1/10, 2/10, etc.)
    const questionInSet = currentQuestionIndex + 1;
    const totalInSet = shuffledQuizData.length;
    
    // Track questions used for this quiz set (update max questions reached)
    loadQuizSetQuestionsUsed();
    updateQuizSetQuestionsUsed(quizSetNumber.toString(), questionInSet);
    if (questionNumber) {
        questionNumber.textContent = questionInSet;
    }
    const totalQuestionsSpan = document.getElementById('total-questions');
    if (totalQuestionsSpan) {
        totalQuestionsSpan.textContent = totalInSet;
    }
    
    // Update quiz set number display
    const quizSetNumberDisplay = document.getElementById('quiz-set-number-display');
    if (quizSetNumberDisplay) {
        // Display 1-17 for first 17 tests, then 18 for the last test (18th test)
        if (currentQuizSetIndex < 17) {
            quizSetNumberDisplay.textContent = currentQuizSetIndex + 1;
        } else {
            quizSetNumberDisplay.textContent = 18; // Last test is the 18th test
        }
    }
    
    // Update exhausted quiz sets display
    updateExhaustedQuizSetsDisplay();
    
    // Display topic
    if (question.topic && question.topic.trim()) {
        topicTitle.textContent = question.topic;
        topicTitle.style.display = 'block';
    } else {
        topicTitle.style.display = 'none';
    }
    
    // Display question
    questionText.textContent = question.question;
    
    // Display answers (cleaned from materials)
    const answerButtons = answersSection.querySelectorAll('.answer-btn');
    answerButtons.forEach((btn, index) => {
        const answerText = btn.querySelector('.answer-text');
        if (question.answers && question.answers[index]) {
            btn.disabled = false;
            btn.classList.remove('correct', 'incorrect');
            btn.style.display = 'flex'; // Show button
            // Clean answer text - remove materials
            const cleanedAnswer = cleanAnswerText(question.answers[index]);
            // Only set text if cleaned answer is not empty
            if (cleanedAnswer && cleanedAnswer.trim()) {
                answerText.textContent = cleanedAnswer;
            } else {
                // If cleaned answer is empty, use original answer
                answerText.textContent = question.answers[index];
            }
        } else {
            btn.style.display = 'none'; // Hide button if no answer
        }
    });
    
    // Display materials (used sources) for this question
    displayMaterials(question);
    
    // Display abbreviations for this question
    displayAbbreviations(question);
    
    if (nextSection) nextSection.style.display = 'none';
}

// Handle answer selection
function selectAnswer(selectedIndex) {
    if (!gameStarted) {
        return;
    }
    
    if (!shuffledQuizData || shuffledQuizData.length === 0) {
        return;
    }
    
    const question = shuffledQuizData[currentQuestionIndex];
    if (!question) {
        return;
    }
    
    const answerButtons = answersSection.querySelectorAll('.answer-btn');
    
    // Disable all buttons
    answerButtons.forEach(btn => {
        btn.disabled = true;
    });
    
    // Mark user's answer
    userAnswers[currentQuestionIndex] = selectedIndex;
    
    // Show correct answer in green
    answerButtons[question.correct].classList.add('correct');
    
    // Show incorrect answer in red if wrong
    if (selectedIndex !== question.correct) {
        answerButtons[selectedIndex].classList.add('incorrect');
        // Update score display (but don't increment score yet)
    } else {

        score++;
        if (scoreDisplay) scoreDisplay.textContent = score;
    }
    
    // Save progress after answering
    saveQuizProgress();
    
    // CRITICAL: Check session validity after answering (another device might have taken over)
    // Check multiple times to catch any device takeover
    if (gameStarted) {
        setTimeout(() => {
            checkSessionValidity().then(isValid => {
                if (!isValid) {
                    }
            });
        }, 500); // First check after 500ms
        setTimeout(() => {
            checkSessionValidity().then(isValid => {
                if (!isValid) {
                    showSessionInvalidatedError('Մեկ այլ սարք օգտագործում է այս վճարման կոդը: Թեստը դադարեցված է:');
                }
            });
        }, 1500); // Second check after 1.5 seconds
    }
    
    // Show next button
    if (nextSection) nextSection.style.display = 'block';
}

// Move to next question
function nextQuestion() {
    // Prevent double execution
    if (nextQuestion.inProgress) {
        return;
    }
    nextQuestion.inProgress = true;
    
    currentQuestionIndex++;
    loadQuestion();
    
    // Reset flag after a short delay
    setTimeout(() => {
        nextQuestion.inProgress = false;
    }, 100);
}

// Handle info button click - opens info modal
function handleInfoClick(e) {
    if (e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
    }
    const infoModal = document.getElementById('info-modal');
    if (infoModal) {
        infoModal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        localStorage.setItem('infoModalOpen', 'true');
    }
    return false;
}

// Expose functions globally for onclick attributes
window.handleInfoClick = handleInfoClick;

// Helper function to check if dark mode is active - use this everywhere for consistency
function isDarkModeActive() {
    // First check body class (most reliable - reflects current state)
    const hasDarkModeClass = document.body.classList.contains('dark-mode');
    
    // If body has dark-mode class, it's dark mode
    if (hasDarkModeClass) {
        return true;
    }
    
    // Otherwise it's light mode (even if localStorage says 'true', if body doesn't have class, it's not active)
    return false;
}

// Handle dark mode toggle - can be called from onclick attribute or event listener
function handleDarkModeToggle(e) {
    if (e) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
    }
    document.body.classList.toggle('dark-mode');
    const isDarkMode = document.body.classList.contains('dark-mode');
    // Store as string 'true' or 'false' for consistent checking
    localStorage.setItem('darkMode', String(isDarkMode));
    
    // If answers review is currently displayed, refresh it to apply new colors
    const answersReview = document.getElementById('answers-review');
    if (answersReview && (answersReview.style.display === 'block' || answersReview.offsetParent !== null)) {
        // Force refresh (don't toggle off) after a short delay
        setTimeout(() => {
            if (typeof showAnswersReview === 'function') {
                showAnswersReview(true); // Pass true to force refresh
            }
        }, 150);
    }
    
    // Refresh score summary box if it exists (use the same isDarkMode value we just set)
    const scoreBox = document.getElementById('quiz-set-score-box');
    const totalText = document.getElementById('quiz-set-total-text');
    if (scoreBox) {
        // LIGHT mode (isDarkMode = false) = white background (#ffffff)
        // DARK mode (isDarkMode = true) = dark background (#2a2a2a)
        const bgColor = isDarkMode ? '#2a2a2a' : '#ffffff';
        scoreBox.style.setProperty('background', bgColor, 'important');
    }
    if (totalText) {
        // LIGHT mode (isDarkMode = false) = dark text (#666)
        // DARK mode (isDarkMode = true) = light text (#b0b0b0)
        const textColor = isDarkMode ? '#b0b0b0' : '#666';
        totalText.style.setProperty('color', textColor, 'important');
    }
    
    // Remove any inline styles from result-item elements to let CSS handle it
    // This ensures CSS rules (body.dark-mode .result-item) work correctly when mode changes
    // Use multiple requestAnimationFrame calls to ensure DOM is fully updated after class toggle
    const removeInlineStyles = () => {
        const resultItems = document.querySelectorAll('.results-display .result-item');
        resultItems.forEach(item => {
            item.style.removeProperty('background');
            item.style.removeProperty('border-color');
            const label = item.querySelector('.result-label');
            if (label) label.style.removeProperty('color');
            const value = item.querySelector('.result-value');
            if (value) value.style.removeProperty('color');
        });
    };
    
    // Call immediately and also after a short delay to catch any delayed DOM updates
    removeInlineStyles();
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            removeInlineStyles();
        });
    });
    setTimeout(removeInlineStyles, 100);
    
    return false;
}

// Expose functions globally for onclick attributes
window.handleDarkModeToggle = handleDarkModeToggle;

// Show answers review - displays all quiz answers with user's responses
// forceRefresh: if true, will refresh even if already displayed (used for dark mode changes)
function showAnswersReview(forceRefresh = false) {
    // Prevent double execution (unless it's a forced refresh)
    if (showAnswersReview.inProgress && !forceRefresh) {
        return;
    }
    showAnswersReview.inProgress = true;
    
    const answersReview = document.getElementById('answers-review');
    const answersList = document.getElementById('answers-list');
    
    if (!answersReview || !answersList) {
        showAnswersReview.inProgress = false;
        return;
    }
    
    // Check if answers are already displayed - only toggle off if NOT a forced refresh
    if (!forceRefresh && answersReview.style.display === 'block' && answersList.innerHTML.trim() !== '') {
        // Toggle off - hide answers
        answersReview.style.display = 'none';
        // Update button text to "Դիտել պատասխանները"
        const viewAnswersBtn = document.getElementById('view-answers-btn');
        if (viewAnswersBtn) {
            viewAnswersBtn.textContent = '📋 Դիտել պատասխանները';
        }
        showAnswersReview.inProgress = false;
        return;
    }
    
    // Get all questions and answers from the current quiz set or all quiz sets
    let questionsToShow = [];
    
    if (shuffledQuizData && shuffledQuizData.length > 0 && userAnswers && userAnswers.length > 0) {
        // Show answers from current quiz set
        questionsToShow = shuffledQuizData.map((question, index) => ({
            question: question,
            userAnswer: userAnswers[index],
            questionIndex: index + 1
        }));
    } else if (quizSets && quizSets.length > 0) {
        // Show answers from all quiz sets that have been completed
        quizSets.forEach((quizSet, setIndex) => {
            if (quizSetResults[setIndex] && (quizSetResults[setIndex].correct > 0 || quizSetResults[setIndex].wrong > 0)) {
                quizSet.forEach((question, qIndex) => {
                    questionsToShow.push({
                        question: question,
                        userAnswer: null, // Can't get individual answers for completed sets
                        questionIndex: `${setIndex + 1}.${qIndex + 1}`,
                        quizSetIndex: setIndex + 1
                    });
                });
            }
        });
    }
    
    // Check if dark mode is active - prioritize localStorage, fallback to body class
    // localStorage stores 'true' or 'false' as string
    const savedDarkModeValue = localStorage.getItem('darkMode');
    const hasDarkModeClass = document.body.classList.contains('dark-mode');
    
    // isDarkMode = true means DARK MODE (need dark colors), false means LIGHT MODE (need white/light colors)
    // Priority: localStorage value > body class
    let isDarkMode = false;
    if (savedDarkModeValue === 'true') {
        isDarkMode = true;
    } else if (savedDarkModeValue === 'false') {
        isDarkMode = false;
    } else {
        // If localStorage is not set, use body class
        isDarkMode = hasDarkModeClass;
    }
    
    // Generate HTML for answers review with dark mode support
    let html = '<div style="max-width: 800px; margin: 0 auto;">';
    
    // COLOR LOGIC: 
    // If isDarkMode = true (DARK MODE) -> use DARK colors (#1a1a1a, #2a2a2a, etc.)
    // If isDarkMode = false (LIGHT MODE) -> use WHITE/LIGHT colors (#ffffff, #f9f9f9, etc.)
    
    // Question card background: DARK mode = dark (#1a1a1a), LIGHT mode = white (#ffffff)
    const questionCardBg = isDarkMode ? '#1a1a1a' : '#ffffff';
    
    // Question text color: DARK mode = light text (#e0e0e0), LIGHT mode = dark text (#1a1a1a)
    const questionTextColor = isDarkMode ? '#e0e0e0' : '#1a1a1a';
    
    // Empty message color
    const emptyTextColor = isDarkMode ? '#999' : '#666';
    
    // Materials background: DARK mode = dark (#2a2a2a), LIGHT mode = light blue (#e8f4f8)
    const materialsBg = isDarkMode ? '#2a2a2a' : '#e8f4f8';
    const materialsColor = isDarkMode ? '#b0b0b0' : '#666';
    
    // Default answer background: DARK mode = dark (#2a2a2a), LIGHT mode = white (#ffffff)
    const defaultAnswerBg = isDarkMode ? '#2a2a2a' : '#ffffff';
    const defaultBorderColor = isDarkMode ? '#444' : '#ddd';
    
    // Correct answer background: DARK mode = dark green (#1e4d2b), LIGHT mode = light green (#d4edda)
    const correctAnswerBg = isDarkMode ? '#1e4d2b' : '#d4edda';
    const correctBorderColor = '#28a745';
    
    // Wrong answer background: DARK mode = dark red (#4d2b2b), LIGHT mode = light red (#f8d7da)
    const wrongAnswerBg = isDarkMode ? '#4d2b2b' : '#f8d7da';
    const wrongBorderColor = '#dc3545';
    
    // Answer text color: DARK mode = light text (#e0e0e0), LIGHT mode = dark text (#1a1a1a)
    const answerTextColor = isDarkMode ? '#e0e0e0' : '#1a1a1a';
    
    if (questionsToShow.length === 0) {
        html += `<p style="text-align: center; color: ${emptyTextColor}; padding: 20px;">Պատասխանները դեռ հասանելի չեն:</p>`;
    } else {
        questionsToShow.forEach((item, index) => {
            const question = item.question;
            const userAnswerIndex = item.userAnswer;
            const correctAnswerIndex = question.correct;
            
            html += `<div style="margin-bottom: 30px; padding: 20px; background: ${questionCardBg}; border-radius: 10px; border-left: 4px solid #4a90e2;">`;
            html += `<div style="font-weight: bold; margin-bottom: 10px; color: ${questionTextColor};">Հարց ${item.questionIndex}: ${question.question}</div>`;
            
            if (question.materials) {
                html += `<div style="font-size: 0.9em; color: ${materialsColor}; margin-bottom: 15px; padding: 8px; background: ${materialsBg}; border-radius: 5px;">📖 ${question.materials}</div>`;
            }
            
            html += `<div style="margin-top: 15px;">`;
            question.answers.forEach((answer, ansIndex) => {
                const isCorrect = ansIndex === correctAnswerIndex;
                const isUserAnswer = userAnswerIndex !== null && ansIndex === userAnswerIndex;
                
                let bgColor = defaultAnswerBg;
                let borderColor = defaultBorderColor;
                let icon = '';
                
                if (isCorrect) {
                    bgColor = correctAnswerBg;
                    borderColor = correctBorderColor;
                    icon = '✅';
                } else if (isUserAnswer && !isCorrect) {
                    bgColor = wrongAnswerBg;
                    borderColor = wrongBorderColor;
                    icon = '❌';
                }
                
                html += `<div style="padding: 12px; margin-bottom: 8px; background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; display: flex; align-items: center;">`;
                html += `<span style="background: #667eea; color: white; width: 30px; height: 30px; border-radius: 50%; display: inline-flex; align-items: center; justify-content: center; margin-right: 10px; font-weight: bold;">${String.fromCharCode(65 + ansIndex)}</span>`;
                html += `<span style="flex: 1; color: ${answerTextColor};">${answer}</span>`;
                if (icon) {
                    html += `<span style="margin-left: 10px; font-size: 1.2em;">${icon}</span>`;
                }
                html += `</div>`;
            });
            html += `</div>`;
            
            html += `</div>`;
        });
    }
    
    html += '</div>';
    
    answersList.innerHTML = html;
    answersReview.style.display = 'block';
    
    // Update button text to "Թաքցնել պատասխանները" when answers are shown
    const viewAnswersBtnForUpdate = document.getElementById('view-answers-btn');
    if (viewAnswersBtnForUpdate) {
        viewAnswersBtnForUpdate.textContent = '👁️ Թաքցնել պատասխանները';
    }
    
    // Scroll to answers review
    answersReview.scrollIntoView({ behavior: 'smooth', block: 'start' });
    
    // Reset flag after a short delay
    setTimeout(() => {
        showAnswersReview.inProgress = false;
    }, 100);
}

// Show results - displays final quiz results
function showResults() {
    const resultsSection = document.getElementById('results-section');
    if (!resultsSection) {
        return;
    }
    
    // Hide quiz sections
    if (topicSection) topicSection.style.display = 'none';
    if (questionSection) questionSection.style.display = 'none';
    if (answersSection) answersSection.style.display = 'none';
    if (nextSection) nextSection.style.display = 'none';
    
    // Show results section
    resultsSection.style.display = 'block';
    
    // Update final score display (already done in showAllResults, but ensure it's visible)
    const finalScore = document.getElementById('final-score');
    const finalTotal = document.getElementById('final-total');
    const resultsPercentage = document.getElementById('final-percentage');
    
    if (finalScore && finalTotal && resultsPercentage) {
        const totalQuestions = parseInt(finalTotal.textContent) || (score + (userAnswers ? userAnswers.filter(a => a !== null).length - score : 0));
        const totalCorrect = parseInt(finalScore.textContent) || score;
        
        if (totalQuestions > 0 && !resultsPercentage.textContent) {
            const percentage = Math.round((totalCorrect / totalQuestions) * 100);
            resultsPercentage.textContent = `${percentage}%`;
        }
    }
    
    // Hide quiz set results section if it exists
    const quizSetResultsSection = document.getElementById('quiz-set-results-section');
    if (quizSetResultsSection) {
        quizSetResultsSection.style.display = 'none';
    }
    
    // Remove any inline styles from result-item elements to let CSS handle it
    // This ensures CSS rules (body.dark-mode .result-item) work correctly
    const resultItems = document.querySelectorAll('.results-display .result-item');
    resultItems.forEach(item => {
        item.style.removeProperty('background');
        item.style.removeProperty('border-color');
        const label = item.querySelector('.result-label');
        if (label) label.style.removeProperty('color');
        const value = item.querySelector('.result-value');
        if (value) value.style.removeProperty('color');
    });
    
    }

// Show results for current quiz set
function showQuizSetResults() {
    // Calculate results for current quiz set
    let correctCount = 0;
    let wrongCount = 0;
    
    for (let i = 0; i < shuffledQuizData.length; i++) {
        const question = shuffledQuizData[i];
        const userAnswer = userAnswers[i];
        if (userAnswer === question.correct) {
            correctCount++;
        } else if (userAnswer !== undefined) {
            wrongCount++;
        }
    }
    
    // Save results for this quiz set
    quizSetResults[currentQuizSetIndex] = {
        correct: correctCount,
        wrong: wrongCount
    };
    
    // Increment attempt for this quiz set
    const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
    const newAttempts = incrementQuizSetAttempt(quizSetNumber);
    // Track quiz complete in Google Apps Script
    trackQuizProgress('complete', quizSetNumber);
    
    // Hide quiz sections
    if (topicSection) topicSection.style.display = 'none';
    if (questionSection) questionSection.style.display = 'none';
    if (answersSection) answersSection.style.display = 'none';
    if (nextSection) nextSection.style.display = 'none';
    
    // Show results section
    const resultsSection = document.getElementById('results-section');
    if (!resultsSection) {
        return;
    }
    resultsSection.style.display = 'block';
    
    // Show quiz set results
    const quizSetResultsSection = document.getElementById('quiz-set-results-section');
    if (!quizSetResultsSection) {
        // Create results section if it doesn't exist
        createQuizSetResultsSection();
    }
    
    displayQuizSetResults(correctCount, wrongCount);
    
    // Force show next button if there are more quiz sets (backup check)
    setTimeout(() => {
        const resultsNextBtn = document.getElementById('next-quiz-set-btn');
        const resultsFinishBtn = document.getElementById('finish-all-quiz-sets-btn');
        
        if (resultsNextBtn && resultsFinishBtn) {
            const currentIndex = typeof currentQuizSetIndex === 'number' ? currentQuizSetIndex : 0;
            const totalSets = Array.isArray(quizSets) ? quizSets.length : 18;
            const hasMoreSets = currentIndex < totalSets - 1;
            
            if (hasMoreSets) {
                resultsNextBtn.style.display = 'inline-block';
                resultsNextBtn.style.visibility = 'visible';
                resultsNextBtn.style.opacity = '1';
                resultsNextBtn.style.flex = '1';
                resultsNextBtn.style.minWidth = '200px';
                resultsFinishBtn.style.display = 'none';
            }
        }
    }, 200);
}

// Create quiz set results section
function createQuizSetResultsSection() {
    const resultsSection = document.getElementById('results-section');
    if (!resultsSection) {
        return;
    }
    
    // Check if already exists
    if (document.getElementById('quiz-set-results-section')) {
        return;
    }
    
    // Check dark mode using consistent helper function
    const isDarkMode = isDarkModeActive();
    
    // LIGHT mode (isDarkMode = false) = white background (#ffffff)
    // DARK mode (isDarkMode = true) = dark background (#2a2a2a)
    const initialScoreBoxBg = isDarkMode ? '#2a2a2a' : '#ffffff';
    const initialTotalTextColor = isDarkMode ? '#b0b0b0' : '#666';
    
    const quizSetResultsDiv = document.createElement('div');
    quizSetResultsDiv.id = 'quiz-set-results-section';
    quizSetResultsDiv.style.display = 'none';
    quizSetResultsDiv.innerHTML = `
        <div style="text-align: center; padding: 20px;">
            <h2 style="color: #4a90e2; margin-bottom: 20px;">📊 Հարցաթերթիկ #<span id="quiz-set-number">1</span> ավարտված է</h2>
            <div id="quiz-set-score-box" style="background: ${initialScoreBoxBg}; padding: 20px; border-radius: 10px; margin: 20px 0;">
                <div style="font-size: 1.2em; margin-bottom: 15px;">
                    <span style="color: #28a745; font-weight: bold;">✅ Ճիշտ: <span id="quiz-set-correct">0</span></span>
                    <span style="margin: 0 20px;">|</span>
                    <span style="color: #dc3545; font-weight: bold;">❌ Սխալ: <span id="quiz-set-wrong">0</span></span>
                </div>
                <div id="quiz-set-total-text" style="color: ${initialTotalTextColor}; font-size: 0.9em;">
                    Ընդամենը: <span id="quiz-set-total">0</span> հարց
                </div>
            </div>
            <div id="quiz-set-navigation" style="margin-top: 20px; display: none;">
                <button id="finish-all-quiz-sets-btn" class="btn-primary" style="margin: 5px; display: none;">Ավարտել Բոլոր Հարցաթերթիկները</button>
            </div>
        </div>
    `;
    
    resultsSection.insertBefore(quizSetResultsDiv, resultsSection.firstChild);
    
    // Event listeners for buttons in results-section will be added in displayQuizSetResults
}

// Display quiz set results
function displayQuizSetResults(correctCount, wrongCount) {
    const quizSetResultsSection = document.getElementById('quiz-set-results-section');
    if (!quizSetResultsSection) {
        return;
    }
    
    // Check dark mode using consistent helper function
    const isDarkMode = isDarkModeActive();
    
    // Apply dark mode colors to score summary box
    const scoreBox = document.getElementById('quiz-set-score-box');
    const totalText = document.getElementById('quiz-set-total-text');
    if (scoreBox) {
        // LIGHT mode (isDarkMode = false) = white background (#ffffff)
        // DARK mode (isDarkMode = true) = dark background (#2a2a2a)
        const bgColor = isDarkMode ? '#2a2a2a' : '#ffffff';
        scoreBox.style.setProperty('background', bgColor, 'important');
    }
    if (totalText) {
        // LIGHT mode (isDarkMode = false) = dark text (#666)
        // DARK mode (isDarkMode = true) = light text (#b0b0b0)
        const textColor = isDarkMode ? '#b0b0b0' : '#666';
        totalText.style.setProperty('color', textColor, 'important');
    }
    
    // Remove any inline styles from result-item elements to let CSS handle it
    // This ensures CSS rules (body.dark-mode .result-item) work correctly
    const resultItems = document.querySelectorAll('.results-display .result-item');
    resultItems.forEach(item => {
        item.style.removeProperty('background');
        item.style.removeProperty('border-color');
        const label = item.querySelector('.result-label');
        if (label) label.style.removeProperty('color');
        const value = item.querySelector('.result-value');
        if (value) value.style.removeProperty('color');
    });
    
    const quizSetNumber = document.getElementById('quiz-set-number');
    const quizSetCorrect = document.getElementById('quiz-set-correct');
    const quizSetWrong = document.getElementById('quiz-set-wrong');
    const quizSetTotal = document.getElementById('quiz-set-total');
    const nextQuizSetBtn = document.getElementById('next-quiz-set-btn');
    const finishAllBtn = document.getElementById('finish-all-quiz-sets-btn');
    
    // Display quiz set number: 1-17 for first 17 tests, 18 for last test
    if (quizSetNumber) {
        if (currentQuizSetIndex < 17) {
            quizSetNumber.textContent = currentQuizSetIndex + 1;
        } else {
            quizSetNumber.textContent = 18; // Last test is the 18th test
        }
    }
    if (quizSetCorrect) quizSetCorrect.textContent = correctCount;
    if (quizSetWrong) quizSetWrong.textContent = wrongCount;
    if (quizSetTotal) quizSetTotal.textContent = correctCount + wrongCount;
    
    // Show/hide buttons based on whether there are more available quiz sets
    // Get buttons from results-section (moved from quiz-set-navigation)
    const resultsNextBtn = document.getElementById('next-quiz-set-btn');
    const resultsFinishBtn = document.getElementById('finish-all-quiz-sets-btn');
    
    // Always show button if buttons exist - simpler logic
    if (resultsNextBtn && resultsFinishBtn) {
        // Check if there are more quiz sets (simple check - if not the last quiz set)
        // Make sure currentQuizSetIndex is a valid number
        const currentIndex = typeof currentQuizSetIndex === 'number' ? currentQuizSetIndex : 0;
        const totalSets = Array.isArray(quizSets) ? quizSets.length : 18;
        const hasMoreSets = currentIndex < totalSets - 1;
        
        if (hasMoreSets) {
            // Show "Հաջորդ Հարցաթերթիկ" button next to "Կրկնել Հարցաթերթիկը"
            resultsNextBtn.style.display = 'inline-block';
            resultsNextBtn.style.flex = '1';
            resultsNextBtn.style.minWidth = '200px';
            resultsFinishBtn.style.display = 'none';
        } else {
            // Show "Ավարտել Բոլոր Հարցաթերթիկները" button if this is the last quiz set
            resultsNextBtn.style.display = 'none';
            resultsFinishBtn.style.display = 'inline-block';
            resultsFinishBtn.style.flex = '1';
            resultsFinishBtn.style.minWidth = '200px';
        }
        
        // Add event listeners if not already added
        if (!resultsNextBtn.hasAttribute('data-listener-added')) {
            resultsNextBtn.addEventListener('click', startNextQuizSet);
            resultsNextBtn.setAttribute('data-listener-added', 'true');
            }
        if (!resultsFinishBtn.hasAttribute('data-listener-added')) {
            resultsFinishBtn.addEventListener('click', showAllResults);
            resultsFinishBtn.setAttribute('data-listener-added', 'true');
            }
    } else {
        }
    
    // Also update the old buttons in quiz-set-navigation (for backward compatibility)
    if (nextQuizSetBtn && finishAllBtn) {
        nextQuizSetBtn.style.display = 'none';
        finishAllBtn.style.display = 'none';
    }
    
    quizSetResultsSection.style.display = 'block';
    
    // Ensure results section is visible
    const resultsSection = document.getElementById('results-section');
    if (resultsSection) {
        resultsSection.style.display = 'block';
        } else {
        }
    
    // Update final score and percentage display in results section
    // Calculate total score across all completed quiz sets
    let totalCorrect = 0;
    let totalWrong = 0;
    for (let i = 0; i <= currentQuizSetIndex; i++) {
        if (quizSetResults[i]) {
            totalCorrect += quizSetResults[i].correct;
            totalWrong += quizSetResults[i].wrong;
        }
    }
    
    const totalQuestions = totalCorrect + totalWrong;
    
    // Update immediately and also with setTimeout as fallback
    const updateScoreDisplay = () => {
        const finalScore = document.getElementById('final-score');
        const finalTotal = document.getElementById('final-total');
        const resultsPercentage = document.getElementById('final-percentage');
        
        if (finalScore) {
            finalScore.textContent = totalCorrect;
            } else {
            }
        if (finalTotal) {
            finalTotal.textContent = totalQuestions;
            } else {
            }
        if (resultsPercentage) {
            if (totalQuestions > 0) {
                const percentage = Math.round((totalCorrect / totalQuestions) * 100);
                resultsPercentage.textContent = `${percentage}%`;
        } else {
            resultsPercentage.textContent = '0%';
            }
        } else {
            }
    };
    
    // Try immediately
    updateScoreDisplay();
    
    // Also try with setTimeout as fallback
    setTimeout(updateScoreDisplay, 100);
    setTimeout(updateScoreDisplay, 500);
    
    }

// Start next quiz set
function startNextQuizSet() {
    currentQuizSetIndex++;
    
    if (currentQuizSetIndex >= quizSets.length) {
        showAllResults();
        return;
    }
    
    // Load next quiz set
    shuffledQuizData = [...quizSets[currentQuizSetIndex]];
    currentQuestionIndex = 0;
    score = 0;
    userAnswers = [];
    
    // Update attempts display for the new quiz set
    const quizSetNumber = currentQuizSetIndex < 17 ? currentQuizSetIndex + 1 : 18;
    const attempts = getQuizSetAttempts(quizSetNumber.toString());
    updateAttemptsDisplay(attempts);
    
    // Hide results, show quiz
    const quizSetResultsSection = document.getElementById('quiz-set-results-section');
    if (quizSetResultsSection) {
        quizSetResultsSection.style.display = 'none';
    }
    
    // Hide results section (score and percentage) when starting new quiz set
    const resultsSection = document.getElementById('results-section');
    if (resultsSection) {
        resultsSection.style.display = 'none';
    }
    
    if (topicSection) topicSection.style.display = 'block';
    if (questionSection) questionSection.style.display = 'block';
    if (answersSection) answersSection.style.display = 'flex';
    if (nextSection) nextSection.style.display = 'none';
    
    loadQuestion();
}

// Show all quiz sets results
function showAllResults() {
    // Calculate total results
    let totalCorrect = 0;
    let totalWrong = 0;
    
    quizSetResults.forEach(result => {
        totalCorrect += result.correct;
        totalWrong += result.wrong;
    });
    
    // Hide quiz set results
    const quizSetResultsSection = document.getElementById('quiz-set-results-section');
    if (quizSetResultsSection) {
        quizSetResultsSection.style.display = 'none';
    }
    
    // Show final results
    score = totalCorrect;
    const totalQuestions = totalCorrect + totalWrong;
    
    // Update final score and percentage display
    const finalScore = document.getElementById('final-score');
    const finalTotal = document.getElementById('final-total');
    const resultsPercentage = document.getElementById('final-percentage');
    
    if (finalScore) {
        finalScore.textContent = totalCorrect;
    }
    if (finalTotal) {
        finalTotal.textContent = totalQuestions;
    }
    if (resultsPercentage && totalQuestions > 0) {
        const percentage = Math.round((totalCorrect / totalQuestions) * 100);
        resultsPercentage.textContent = `${percentage}%`;
        
        if (percentage === 100) {
            resultsPercentage.textContent += ' - Գերազանց!';
        } else if (percentage >= 70) {
            resultsPercentage.textContent += ' - Լավ արդյունք!';
        } else if (percentage >= 50) {
            resultsPercentage.textContent += ' - Միջին արդյունք';
        } else {
            resultsPercentage.textContent += ' - Կարող եք ավելի լավ անել';
        }
    }
    
    userAnswers = []; // Clear for final results display
    shuffledQuizData = []; // Clear for final results display
    
    showResults();
}

// Collect device information
function getDeviceInfo() {
    const ua = navigator.userAgent;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
    const isTablet = /iPad|Android/i.test(ua) && !/Mobile/i.test(ua);
    
    let deviceType = 'Desktop';
    if (isMobile) deviceType = 'Mobile';
    else if (isTablet) deviceType = 'Tablet';
    
    // Browser detection
    let browser = 'Unknown';
    if (ua.includes('Chrome') && !ua.includes('Edg')) browser = 'Chrome';
    else if (ua.includes('Firefox')) browser = 'Firefox';
    else if (ua.includes('Safari') && !ua.includes('Chrome')) browser = 'Safari';
    else if (ua.includes('Edg')) browser = 'Edge';
    else if (ua.includes('Opera') || ua.includes('OPR')) browser = 'Opera';
    
    // OS detection
    let os = 'Unknown';
    if (ua.includes('Windows')) os = 'Windows';
    else if (ua.includes('Mac')) os = 'macOS';
    else if (ua.includes('Linux')) os = 'Linux';
    else if (ua.includes('Android')) os = 'Android';
    else if (ua.includes('iOS')) os = 'iOS';
    
    return {
        deviceType: deviceType,
        browser: browser,
        os: os,
        userAgent: ua,
        screenWidth: window.screen.width,
        screenHeight: window.screen.height,
        viewportWidth: window.innerWidth,
        viewportHeight: window.innerHeight,
        language: navigator.language,
        platform: navigator.platform
    };
}

// Get user location (IP-based, approximate)
async function getUserLocation() {
    try {
        // Try to get precise location if user allows
        if (navigator.geolocation) {
            return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        // Get precise location with city info from IP
                        getIPLocation().then(ipData => {
                            resolve({
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude,
                                accuracy: position.coords.accuracy,
                                country: ipData.country || 'Unknown',
                                city: ipData.city || 'Unknown',
                                region: ipData.region || 'Unknown',
                                source: 'geolocation'
                            });
                        });
                    },
                    () => {
                        // If geolocation fails, try IP-based location
                        getIPLocation().then(resolve);
                    },
                    { 
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }
                );
            });
        } else {
            // Fallback to IP-based location
            return await getIPLocation();
        }
    } catch (error) {
        return await getIPLocation();
    }
}

// Get approximate location from IP (with multiple fallback services)
async function getIPLocation() {
    // Try multiple IP geolocation services for better accuracy
    const services = [
        {
            url: 'https://ipapi.co/json/',
            parse: (data) => ({
                country: data.country_name || data.country || 'Unknown',
                city: data.city || 'Unknown',
                region: data.region || data.region_name || 'Unknown',
                latitude: data.latitude || null,
                longitude: data.longitude || null,
                ip: data.ip || 'Unknown'
            })
        },
        {
            url: 'https://ip-api.com/json/',
            parse: (data) => ({
                country: data.country || 'Unknown',
                city: data.city || 'Unknown',
                region: data.regionName || 'Unknown',
                latitude: data.lat || null,
                longitude: data.lon || null,
                ip: data.query || 'Unknown'
            })
        },
        {
            url: 'https://api.ipgeolocation.io/ipgeo?apiKey=free',
            parse: (data) => ({
                country: data.country_name || 'Unknown',
                city: data.city || 'Unknown',
                region: data.state_prov || 'Unknown',
                latitude: data.latitude || null,
                longitude: data.longitude || null,
                ip: data.ip || 'Unknown'
            })
        }
    ];

    // Try each service until one works
    for (const service of services) {
        try {
            const response = await fetch(service.url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                const location = service.parse(data);
                return {
                    ...location,
                    source: 'ip-api'
                };
            }
        } catch (error) {
            continue;
        }
    }

    // If all services fail, return default
    return {
        country: 'Unknown',
        city: 'Unknown',
        region: 'Unknown',
        latitude: null,
        longitude: null,
        ip: 'Unknown',
        source: 'error'
    };
}

// Send tracking data to server
async function sendTrackingData(userData) {
    try {
        // Google Apps Script Web App URL
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbw-3sJlF6BZwja_BrvRESuaEX_Hydi0heHTDIn8hmYfLS9TS1yTx689Rz0_CVr0iRbaHw/exec';
        
        if (!WEB_APP_URL || WEB_APP_URL === 'YOUR_GOOGLE_APPS_SCRIPT_WEB_APP_URL') {
            return;
        }
        
        // Method 1: Try JSON POST (no-cors)
        fetch(WEB_APP_URL, {
            method: 'POST',
            mode: 'no-cors',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                timestamp: userData.timestamp || new Date().toISOString(),
                name: userData.name || 'Անանուն',
                score: userData.score || 0,
                totalQuestions: userData.totalQuestions || 0,
                percentage: userData.percentage || 0,
                deviceType: userData.deviceInfo?.deviceType || 'Unknown',
                browser: userData.deviceInfo?.browser || 'Unknown',
                os: userData.deviceInfo?.os || 'Unknown',
                city: userData.location?.city || 'Unknown',
                country: userData.location?.country || 'Unknown'
            })
        }).then(() => {
        }).catch((error) => {
            });
        
        // Method 2: Try GET request (image tag - always works)
        const img = document.createElement('img');
        const params = new URLSearchParams();
        params.append('timestamp', userData.timestamp || new Date().toISOString());
        params.append('name', userData.name || 'Անանուն');
        params.append('score', userData.score || 0);
        params.append('totalQuestions', userData.totalQuestions || 0);
        params.append('percentage', userData.percentage || 0);
        params.append('deviceType', userData.deviceInfo?.deviceType || 'Unknown');
        params.append('browser', userData.deviceInfo?.browser || 'Unknown');
        params.append('os', userData.deviceInfo?.os || 'Unknown');
        params.append('city', userData.location?.city || 'Unknown');
        params.append('country', userData.location?.country || 'Unknown');
        
        img.src = WEB_APP_URL + '?' + params.toString();
        img.style.display = 'none';
        img.style.width = '1px';
        img.style.height = '1px';
        document.body.appendChild(img);
        
        setTimeout(() => {
            if (img.parentNode) {
                img.parentNode.removeChild(img);
            }
        }, 2000);
        
    } catch (error) {
        }
}

// Show final results
async function showResults() {
    if (topicSection) topicSection.style.display = 'none';
    if (questionSection) questionSection.style.display = 'none';
    if (answersSection) answersSection.style.display = 'none';
    if (nextSection) nextSection.style.display = 'none';
    if (resultsSection) resultsSection.style.display = 'block';
    
    const finalScore = document.getElementById('final-score');
    const finalTotal = document.getElementById('final-total');
    const resultsPercentage = document.getElementById('final-percentage');
    
    // Increment quiz attempts when completing the full test (all 175 questions)
    const newAttempts = incrementQuizAttempts();
    const remaining = Math.max(0, 3 - newAttempts);
    
    // Update attempts display
    updateAttemptsDisplay(newAttempts);
    
    if (finalScore) {
        finalScore.textContent = score;
    }
    if (finalTotal) {
        finalTotal.textContent = shuffledQuizData.length;
    }
    if (resultsPercentage && shuffledQuizData.length > 0) {
        const percentage = Math.round((score / shuffledQuizData.length) * 100);
        resultsPercentage.textContent = `${percentage}%`;
    }
    
    // Show remaining attempts
    const remainingAttemptsDisplay = document.getElementById('remaining-attempts-display');
    const remainingAttemptsValue = document.getElementById('remaining-attempts-value');
    if (remainingAttemptsDisplay && remainingAttemptsValue) {
        remainingAttemptsDisplay.style.display = 'flex';
        remainingAttemptsValue.textContent = `${remaining} անգամ`;
        if (remaining === 0) {
            remainingAttemptsValue.style.color = '#dc3545';
        } else {
            remainingAttemptsValue.style.color = '#28a745';
        }
    }
    
    if (percentage === 100) {
        resultsPercentage.textContent += ' - Գերազանց!';
    } else if (percentage >= 70) {
        resultsPercentage.textContent += ' - Լավ արդյունք!';
    } else if (percentage >= 50) {
        resultsPercentage.textContent += ' - Միջին արդյունք';
    } else {
        resultsPercentage.textContent += ' - Կարող եք ավելի լավ անել';
    }
    
    // Collect and send tracking data
    userData.name = userName || 'Անանուն';
    userData.score = score;
    userData.totalQuestions = shuffledQuizData.length;
    userData.percentage = percentage;
    userData.attempts = attempts;
    userData.remainingAttempts = remaining;
    userData.deviceInfo = getDeviceInfo();
    userData.timestamp = new Date().toISOString();
    userData.answers = userAnswers.map((answer, index) => ({
        questionIndex: index,
        userAnswer: answer !== undefined ? answer : null,
        correctAnswer: shuffledQuizData[index].correct,
        isCorrect: answer === shuffledQuizData[index].correct,
        question: shuffledQuizData[index].question,
        topic: shuffledQuizData[index].topic
    }));
    
    // Get location (async) - with timeout to not block saving
    try {
        // Set timeout for location (max 5 seconds) - don't block localStorage save
        const locationPromise = getUserLocation();
        const timeoutPromise = new Promise((resolve) => {
            setTimeout(() => {
                resolve({
                    country: 'Unknown',
                    city: 'Unknown',
                    latitude: null,
                    longitude: null,
                    source: 'timeout'
                });
            }, 5000);
        });
        
        userData.location = await Promise.race([locationPromise, timeoutPromise]);
        } catch (error) {
        userData.location = {
            country: 'Unknown',
            city: 'Unknown',
            latitude: null,
            longitude: null,
            source: 'error'
        };
    }
    
    // CRITICAL: Save to localStorage FIRST (before any async operations)
    try {
        const existingData = JSON.parse(localStorage.getItem('quizResults') || '[]');
        existingData.push(userData);
        localStorage.setItem('quizResults', JSON.stringify(existingData));
        
        // Verify it was saved
        const verify = JSON.parse(localStorage.getItem('quizResults') || '[]');
        if (verify.length === 0) {
            } else {
            }
    } catch (error) {
        // Try to save anyway with error handling
        try {
            localStorage.setItem('quizResults', JSON.stringify([userData]));
            } catch (e) {
            alert('Սխալ: Տվյալները չեն պահպանվել: ' + e.message);
        }
    }
    
    // Send tracking data (non-blocking - don't wait for it)
    sendTrackingData(userData).catch(err => {
        // Error sending tracking data
    });
    
    // Hide answers review initially
    answersReview.style.display = 'none';
    
    // Clear quiz progress when quiz is completed
    localStorage.removeItem('quizProgress');
}

// NOTE: Duplicate showAnswersReview function and duplicate initialization code removed (was at line 7417-7868)
// All duplicate functions (initializeEventListeners, initializeUIButtons, saveScrollPosition, restoreScrollPosition,
// showAnswersReview) and duplicate initialization code have been removed.
// These are already defined earlier in the file (around line 5802, 5858, 6047, 6157, 6227, etc.)
// Duplicate code was causing button event listeners to not work properly

// Initialize Event Listeners - Must be called after DOM is loaded
// Flag to prevent duplicate initialization
let eventListenersInitialized = false;

function initializeEventListeners() {
    if (eventListenersInitialized) {
        return;
    }
    
    // Get fresh references to DOM elements
    const startBtn = document.getElementById('start-btn');
    const backToPaymentBtn = document.getElementById('back-to-payment-btn');
    const backToPaymentFromQuizBtn = document.getElementById('back-to-payment-from-quiz-btn');
    const restartBtn = document.getElementById('restart-btn');
    const repeatQuizBtn = document.getElementById('repeat-quiz-btn');
    const changeQuizBtn = document.getElementById('change-quiz-btn');
    const verifyPaymentBtn = document.getElementById('verify-payment-btn');
    const verifyPaymentBtnAfter = document.getElementById('verify-payment-btn-after');
    const nextBtn = document.getElementById('next-btn');
    const viewAnswersBtn = document.getElementById('view-answers-btn');
    const paymentCodeInput = document.getElementById('payment-code');
    const paymentCodeInputAfter = document.getElementById('payment-code-after');
    const userNameInput = document.getElementById('user-name');
    const startSection = document.getElementById('start-section');
    const paymentSection = document.getElementById('payment-section');
    const topicSection = document.getElementById('topic-section');
    const questionSection = document.getElementById('question-section');
    const answersSection = document.getElementById('answers-section');
    const nextSection = document.getElementById('next-section');
    const resultsSection = document.getElementById('results-section');
    
    // Start Quiz button
    if (startBtn) {
        startBtn.onclick = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            startQuiz();
            return false;
        };
        startBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            startQuiz();
        }, { capture: true, passive: false });
        } else {
        }
    
    // Back to payment button
    if (backToPaymentBtn) {
        backToPaymentBtn.addEventListener('click', () => {
            if (startSection) startSection.style.display = 'none';
            if (paymentSection) paymentSection.style.display = 'block';
        });
        }
    
    // Back to payment from quiz button
    if (backToPaymentFromQuizBtn) {
        backToPaymentFromQuizBtn.addEventListener('click', () => {
            if (topicSection) topicSection.style.display = 'none';
            if (questionSection) questionSection.style.display = 'none';
            if (answersSection) answersSection.style.display = 'none';
            if (nextSection) nextSection.style.display = 'none';
            if (resultsSection) resultsSection.style.display = 'none';
            if (startSection) startSection.style.display = 'none';
            if (paymentSection) paymentSection.style.display = 'block';
            gameStarted = false;
            currentQuestionIndex = 0;
            score = 0;
            userAnswers = [];
        });
        }
    
    // Restart button
    if (restartBtn) {
        restartBtn.addEventListener('click', initGame);
        }
    
    // Repeat quiz button
    if (repeatQuizBtn) {
        repeatQuizBtn.addEventListener('click', repeatQuiz);
        }
    
    // Change quiz button
    if (changeQuizBtn) {
        // change-quiz-btn removed - replaced with next-quiz-set-btn
        // changeQuizBtn.addEventListener('click', changeQuiz);
        // }
    
    // Verify payment buttons
    if (verifyPaymentBtn) {
        verifyPaymentBtn.onclick = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            verifyPaymentCode();
            return false;
        };
        verifyPaymentBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            verifyPaymentCode();
        }, { capture: true, passive: false });
        } else {
        }
    
    if (verifyPaymentBtnAfter) {
        verifyPaymentBtnAfter.onclick = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            verifyPaymentCode();
            return false;
        };
        verifyPaymentBtnAfter.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            verifyPaymentCode();
        }, { capture: true, passive: false });
    } else {
    }
    
    // Payment code input Enter key
    if (paymentCodeInput) {
        paymentCodeInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                verifyPaymentCode();
            }
        });
        }
    
    if (paymentCodeInputAfter) {
        paymentCodeInputAfter.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                verifyPaymentCode();
            }
        });
    }
    
    // Next button
    if (nextBtn) {
        nextBtn.addEventListener('click', nextQuestion);
        }
    
    // View answers button
    if (viewAnswersBtn) {
        // Remove existing onclick handler if any
        viewAnswersBtn.removeAttribute('onclick');
        viewAnswersBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            showAnswersReview();
        });
        } else {
        }
    
    // User name input Enter key
    if (userNameInput) {
        userNameInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                startQuiz();
            }
        });
        }
    
    // Answer buttons (dynamically added, so we use event delegation)
    // Handle clicks on button or any child element (answer-letter, answer-text)
    document.addEventListener('click', function(e) {
        let answerBtn = null;
        
        // Check if clicked element is the button itself
        if (e.target.classList.contains('answer-btn')) {
            answerBtn = e.target;
        }
        // Check if clicked element is answer-letter or answer-text
        else if (e.target.classList.contains('answer-letter') || e.target.classList.contains('answer-text')) {
            answerBtn = e.target.closest('.answer-btn');
        }
        // Try to find closest answer-btn parent
        else {
            answerBtn = e.target.closest('.answer-btn');
        }
        
        if (answerBtn) {
            }
        
        if (answerBtn && !answerBtn.disabled) {
            const selectedIndex = parseInt(answerBtn.getAttribute('data-index'));
            if (!isNaN(selectedIndex)) {
                e.preventDefault();
                e.stopPropagation();
                selectAnswer(selectedIndex);
            }
        } else if (answerBtn && answerBtn.disabled) {
            }
    });
    
    // Enter key to go to next question
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && nextSection && nextSection.style.display === 'block') {
            e.preventDefault();
            nextQuestion();
        }
    });
    // Mark as initialized
    eventListenersInitialized = true;
    
    }

// Flag to prevent duplicate initialization
let uiButtonsInitialized = false;

// Initialize Info Modal and Dark Mode Toggle when DOM is ready
function initializeUIButtons() {
    if (uiButtonsInitialized) {
        return;
    }
    
    // Info Modal functionality
    const infoBtn = document.getElementById('info-btn');
    const infoModal = document.getElementById('info-modal');
    const infoModalClose = document.getElementById('info-modal-close');
    const infoBackBtn = document.getElementById('info-back-btn');

    if (infoBtn) {
        // Remove any existing listeners by cloning
        const newInfoBtn = infoBtn.cloneNode(true);
        infoBtn.parentNode.replaceChild(newInfoBtn, infoBtn);
        
        // Get fresh reference
        const freshInfoBtn = document.getElementById('info-btn');
        const freshInfoModal = document.getElementById('info-modal');
        
        if (freshInfoBtn) {
            // Add multiple event listeners to ensure it works
            function handleInfoClick(e) {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
                if (freshInfoModal) {
                    freshInfoModal.style.display = 'flex';
                    document.body.style.overflow = 'hidden';
                    // Save modal state
                    localStorage.setItem('infoModalOpen', 'true');
                }
                return false;
            }
            
            freshInfoBtn.addEventListener('click', handleInfoClick, { capture: true, passive: false });
            freshInfoBtn.addEventListener('mousedown', handleInfoClick, { capture: true, passive: false });
            freshInfoBtn.onclick = handleInfoClick;
            
            }
    } else {
        }

    if (infoModalClose) {
        infoModalClose.addEventListener('click', () => {
            if (infoModal) {
                infoModal.style.display = 'none';
                document.body.style.overflow = 'auto';
                // Save modal state
                localStorage.setItem('infoModalOpen', 'false');
            }
        });
    }

    if (infoBackBtn) {
        infoBackBtn.addEventListener('click', () => {
            if (infoModal) {
                infoModal.style.display = 'none';
                document.body.style.overflow = 'auto';
                // Save modal state
                localStorage.setItem('infoModalOpen', 'false');
            }
        });
    }

    // Close modal when clicking outside
    if (infoModal) {
        infoModal.addEventListener('click', (e) => {
            if (e.target === infoModal) {
                infoModal.style.display = 'none';
                document.body.style.overflow = 'auto';
                // Save modal state
                localStorage.setItem('infoModalOpen', 'false');
            }
        });
    }
    
    // Restore modal state if it was open
    const wasModalOpen = localStorage.getItem('infoModalOpen') === 'true';
    if (wasModalOpen && infoModal) {
        infoModal.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        }

    // Dark Mode Toggle
    const darkModeToggle = document.getElementById('dark-mode-toggle');

    // Load saved dark mode preference
    const savedDarkMode = localStorage.getItem('darkMode') === 'true';
    if (savedDarkMode) {
        document.body.classList.add('dark-mode');
    }

    // Toggle dark mode - use onclick attribute (handleDarkModeToggle is global)
    // Don't remove onclick, just ensure handleDarkModeToggle is available
    if (darkModeToggle) {
        // Ensure handleDarkModeToggle is available globally (already done at end of file)
        if (typeof window.handleDarkModeToggle !== 'function') {
            window.handleDarkModeToggle = handleDarkModeToggle;
        }
        
        // Also add event listener as backup (onclick will work too)
        darkModeToggle.addEventListener('click', function(e) {
            // Let onclick handle it, but also do it here as backup
            if (!e.defaultPrevented) {
                handleDarkModeToggle(e);
            }
        }, { capture: false, passive: false });
    } else {
        }
    
    // Mark as initialized
    uiButtonsInitialized = true;
    }

// Save scroll position
function saveScrollPosition() {
    try {
        const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
        localStorage.setItem('mainMenuScrollPosition', scrollY.toString());
    } catch (error) {
        }
}

// Restore scroll position
function restoreScrollPosition() {
    try {
        const savedScroll = localStorage.getItem('mainMenuScrollPosition');
        if (savedScroll !== null) {
            const scrollY = parseInt(savedScroll, 10);
            // Use requestAnimationFrame to ensure DOM is ready
            requestAnimationFrame(() => {
                window.scrollTo(0, scrollY);
            });
        }
    } catch (error) {
        }
}

// Save scroll position on scroll (throttled)
let scrollTimeout;
window.addEventListener('scroll', function() {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
        saveScrollPosition();
    }, 100); // Save after 100ms of no scrolling
}, { passive: true });

// CRITICAL: Prevent page reload on minimize/maximize
// Set flags IMMEDIATELY when page starts to unload
window.addEventListener('beforeunload', function(e) {
    saveScrollPosition();
    // CRITICAL: Set flags to prevent reset on return
    try {
        sessionStorage.setItem('pageUnloading', 'true');
        sessionStorage.setItem('pageInitialized', 'true');
        // Also set in localStorage as backup (persists across reloads)
        localStorage.setItem('pageUnloading', 'true');
        localStorage.setItem('pageInitialized', 'true');
    } catch (error) {
        }
}, { capture: true });

// CRITICAL: Also set flags on pagehide (for mobile browsers and when browser minimizes)
window.addEventListener('pagehide', function(e) {
    saveScrollPosition();
    // CRITICAL: Set flags to prevent reset on return
    try {
        sessionStorage.setItem('pageUnloading', 'true');
        sessionStorage.setItem('pageInitialized', 'true');
        // Also set in localStorage as backup
        localStorage.setItem('pageUnloading', 'true');
        localStorage.setItem('pageInitialized', 'true');
    } catch (error) {
        }
}, { capture: true });

// Restore scroll position on pageshow (merged with progress restore handler below)
// This handler is now merged with the main pageshow handler

// Flag to track if we're restoring from pageshow
let isRestoringFromPageshow = false;
// Flag to track if page has been initialized (to prevent re-initialization on minimize/maximize)
// Use MULTIPLE methods to persist across minimize/maximize:
// 1. window.name (persists across page navigation)
// 2. sessionStorage (persists in same tab)
let pageInitialized = false;

// Check window.name first (most reliable for minimize/maximize)
if (window.name && window.name.includes('quizPageInitialized')) {
    pageInitialized = true;
    isRestoringFromPageshow = true;
}

// Check sessionStorage AND localStorage as backup (MAXIMUM RELIABILITY)
try {
    if (sessionStorage.getItem('pageInitialized') === 'true' || localStorage.getItem('pageInitialized') === 'true') {
        pageInitialized = true;
        isRestoringFromPageshow = true;
    }
} catch (e) {
    // sessionStorage/localStorage not available, use variable only
}

// CRITICAL: Handle pageshow FIRST (before DOMContentLoaded) to prevent reset on minimize/maximize
window.addEventListener('pageshow', function(event) {
    // Restore dark mode preference immediately
    try {
        const savedDarkMode = localStorage.getItem('darkMode') === 'true';
        if (savedDarkMode) {
            document.body.classList.add('dark-mode');
            } else {
            document.body.classList.remove('dark-mode');
            }
    } catch (e) {
        // localStorage not available
    }
    
    // CRITICAL: Check if pageUnloading flag exists (even if persisted: false)
    // This handles the case when page reloads after minimize
    // Check BOTH sessionStorage AND localStorage for maximum reliability
    let hadUnloadingFlag = false;
    try {
        // Check sessionStorage first
        if (sessionStorage.getItem('pageUnloading') === 'true') {
            hadUnloadingFlag = true;
            sessionStorage.removeItem('pageUnloading');
        }
        // Also check localStorage as backup
        if (!hadUnloadingFlag && localStorage.getItem('pageUnloading') === 'true') {
            hadUnloadingFlag = true;
            localStorage.removeItem('pageUnloading');
        }
    } catch (e) {
        // sessionStorage/localStorage not available
    }
    
    // If page was restored from cache (minimize/maximize) OR had unloading flag, don't reset
    // NOTE: Even if persisted: false, if pageUnloading was set, it means we're returning from minimize
    if (event.persisted || pageInitialized || hadUnloadingFlag) {
        isRestoringFromPageshow = true;
        pageInitialized = true;
        window.name = 'quizPageInitialized_' + Date.now();
        try {
            sessionStorage.setItem('pageInitialized', 'true');
            localStorage.setItem('pageInitialized', 'true'); // Also set in localStorage as backup
        } catch (e) {
            // sessionStorage/localStorage not available, continue anyway
        }
    }
}, { capture: true, passive: true });

// Initialize when DOM is ready
// CRITICAL: Check pageUnloading flag IMMEDIATELY (before DOMContentLoaded)
// This must be checked synchronously, not in event handler
// Check BOTH sessionStorage AND localStorage for maximum reliability
let wasUnloading = false;
try {
    // Check sessionStorage first
    wasUnloading = sessionStorage.getItem('pageUnloading') === 'true';
    if (!wasUnloading) {
        // Also check localStorage as backup
        wasUnloading = localStorage.getItem('pageUnloading') === 'true';
    }
    if (wasUnloading) {
        // Clear the flags, but keep initialized flag
        try {
            sessionStorage.removeItem('pageUnloading');
            localStorage.removeItem('pageUnloading');
        } catch (e) {
            // Ignore errors
        }
        pageInitialized = true;
        isRestoringFromPageshow = true;
    }
} catch (e) {
    // sessionStorage/localStorage not available
}

if (document.readyState === 'loading') {
    // Check if we need to clear localStorage (for testing cross-device sync)
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('clear-storage') === '1') {
        localStorage.clear();
        sessionStorage.clear();
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        // Restore dark mode preference IMMEDIATELY before any other initialization
        try {
            const savedDarkMode = localStorage.getItem('darkMode') === 'true';
            if (savedDarkMode) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
            
            // Remove any inline styles from result-item elements to let CSS handle it
            // This ensures CSS rules (body.dark-mode .result-item) work correctly
            const removeInlineStyles = () => {
                const resultItems = document.querySelectorAll('.results-display .result-item');
                resultItems.forEach(item => {
                    item.style.removeProperty('background');
                    item.style.removeProperty('border-color');
                    const label = item.querySelector('.result-label');
                    if (label) label.style.removeProperty('color');
                    const value = item.querySelector('.result-value');
                    if (value) value.style.removeProperty('color');
                });
            };
            removeInlineStyles();
            setTimeout(removeInlineStyles, 100);
            
            // Set up MutationObserver to watch for dark-mode class changes
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        removeInlineStyles();
                    }
                });
            });
            observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
        } catch (e) {
            // localStorage not available
        }
        
        // CRITICAL: Always initialize event listeners first (needed for verifyPaymentCode button)
        // Initialize immediately - DOMContentLoaded ensures DOM is ready
        // Use requestAnimationFrame to ensure DOM is fully rendered
        requestAnimationFrame(() => {
            setTimeout(() => {
                initializeEventListeners();
                initializeUIButtons();
                
                // Initialize idle animation detection
                initIdleDetection();
            }, 100);
        });
        
        // CRITICAL: Check payment status FIRST - if valid, don't call initGame() at all
        const paymentCode = localStorage.getItem('paymentCode');
        const paymentToken = localStorage.getItem('paymentToken');
        if (paymentCode && paymentToken) {
            // User has active payment - check status and restore UI without calling initGame()
            checkPaymentStatus().then(paymentStatus => {
                if (paymentStatus.paid) {
                    // Payment is valid - restore UI immediately without calling initGame()
                    if (paymentSection) paymentSection.style.display = 'none';
                    if (startSection) startSection.style.display = 'block';
                    
                    // Try to restore progress
                    loadQuizProgress().then(savedProgress => {
                        if (savedProgress && savedProgress.gameStarted && savedProgress.paymentCode === paymentCode) {
                            // Restore progress and continue quiz
                            currentQuestionIndex = savedProgress.currentQuestionIndex || 0;
                            score = savedProgress.score || 0;
                            userAnswers = savedProgress.userAnswers || [];
                            gameStarted = savedProgress.gameStarted;
                            if (typeof currentQuizSetIndex !== 'undefined' && savedProgress.currentQuizSetIndex >= 0) {
                                currentQuizSetIndex = savedProgress.currentQuizSetIndex;
                            }
                            
                            // Restore shuffled quiz data
                            if (savedProgress.shuffledQuizData && savedProgress.shuffledQuizData.length > 0) {
                                shuffledQuizData = [];
                                for (const questionText of savedProgress.shuffledQuizData) {
                                    const foundQuestion = quizData.find(q => q.question === questionText);
                                    if (foundQuestion) {
                                        shuffledQuizData.push(foundQuestion);
                                    }
                                }
                            }
                            
                            // Restore quiz sets if needed
                            if (typeof quizSets === 'undefined' || quizSets.length === 0) {
                                const orderedQuizData = [...quizData];
                                quizSets = [];
                                quizSetResults = [];
                                for (let i = 0; i < 17; i++) {
                                    quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
                                    quizSetResults.push({ correct: 0, wrong: 0 });
                                }
                                quizSets.push(orderedQuizData.slice(170, 175));
                                quizSetResults.push({ correct: 0, wrong: 0 });
                            }
                            
                            // Restore UI to quiz state
                            if (paymentSection) paymentSection.style.display = 'none';
                            if (startSection) startSection.style.display = 'none';
                            if (topicSection) topicSection.style.display = 'block';
                            if (questionSection) questionSection.style.display = 'block';
                            if (answersSection) answersSection.style.display = 'flex';
                            if (nextSection) nextSection.style.display = 'none';
                            if (resultsSection) resultsSection.style.display = 'none';
                            
                            // Load the current question
                            loadQuestion();
                            
                            progressRestored = true;
                            gameInitialized = true;
                            pageInitialized = true;
                            window.name = 'quizPageInitialized_' + Date.now();
                            try {
                                sessionStorage.setItem('pageInitialized', 'true');
                                localStorage.setItem('pageInitialized', 'true');
                            } catch (e) {}
                            
                            }
                    }).catch(err => {
                        });
                    
                    // Restore scroll position
                    setTimeout(() => {
                        restoreScrollPosition();
                    }, 100);
                    
                    return; // Don't call initGame() - we've already restored everything
                }
            }).catch(err => {
                });
        }
        
        // CRITICAL: Double-check pageUnloading flag (in case it was set between script load and DOMContentLoaded)
        // Check BOTH sessionStorage AND localStorage for maximum reliability
        let checkUnloading = false;
        try {
            // Check sessionStorage first
            checkUnloading = sessionStorage.getItem('pageUnloading') === 'true';
            if (!checkUnloading) {
                // Also check localStorage as backup
                checkUnloading = localStorage.getItem('pageUnloading') === 'true';
            }
            if (checkUnloading) {
                // Clear the flags
                try {
                    sessionStorage.removeItem('pageUnloading');
                    localStorage.removeItem('pageUnloading');
                } catch (e) {
                    // Ignore errors
                }
                pageInitialized = true;
                isRestoringFromPageshow = true;
                wasUnloading = true;
            }
        } catch (e) {
            // sessionStorage/localStorage not available
        }
        
        // CRITICAL: Also check pageInitialized flag from sessionStorage AND localStorage (in case it was set before)
        try {
            if (sessionStorage.getItem('pageInitialized') === 'true' || localStorage.getItem('pageInitialized') === 'true') {
                pageInitialized = true;
                isRestoringFromPageshow = true;
            }
        } catch (e) {
            // sessionStorage/localStorage not available
        }
        
        // CRITICAL: Don't initialize if already initialized (check multiple methods INCLUDING initializationInProgress)
        // Check window.name first (most reliable)
        const alreadyInitialized = initializationInProgress ||
                                   (window.name && window.name.includes('quizPageInitialized')) ||
                                   pageInitialized ||
                                   isRestoringFromPageshow ||
                                   wasUnloading ||
                                   checkUnloading ||
                                   gameInitialized;
        
        if (!alreadyInitialized) {
            // Note: initializeEventListeners() and initializeUIButtons() already called above
            // initGame() will set all flags internally
            initGame().then(() => {
                // Restore scroll position after initialization
                setTimeout(() => {
                    restoreScrollPosition();
                }, 100);
            }).catch(err => {
                // Reset flag on error
                initializationInProgress = false;
            });
        } else {
            }
    });
} else {
    // DOM is already loaded
    // Restore dark mode preference IMMEDIATELY before any other initialization
    try {
        const savedDarkMode = localStorage.getItem('darkMode') === 'true';
        if (savedDarkMode) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }
    } catch (e) {
        // localStorage not available
    }
    
    // CRITICAL: Always initialize event listeners first (needed for verifyPaymentCode button)
    // Initialize immediately - DOM is already loaded
    
    // Use requestAnimationFrame to ensure DOM is fully rendered
    requestAnimationFrame(() => {
        setTimeout(() => {
            initializeEventListeners();
            initializeUIButtons();
        }, 100);
    });
    
    // CRITICAL: Check payment status FIRST - if valid, don't call initGame() at all
    const paymentCode = localStorage.getItem('paymentCode');
    const paymentToken = localStorage.getItem('paymentToken');
    if (paymentCode && paymentToken) {
        // User has active payment - check status and restore UI without calling initGame()
        checkPaymentStatus().then(paymentStatus => {
            if (paymentStatus.paid) {
                // Payment is valid - restore UI immediately without calling initGame()
                if (paymentSection) paymentSection.style.display = 'none';
                if (startSection) startSection.style.display = 'block';
                
                // Try to restore progress
                loadQuizProgress().then(savedProgress => {
                    if (savedProgress && savedProgress.gameStarted && savedProgress.paymentCode === paymentCode) {
                        // Restore progress and continue quiz
                        currentQuestionIndex = savedProgress.currentQuestionIndex || 0;
                        score = savedProgress.score || 0;
                        userAnswers = savedProgress.userAnswers || [];
                        gameStarted = savedProgress.gameStarted;
                        if (typeof currentQuizSetIndex !== 'undefined' && savedProgress.currentQuizSetIndex >= 0) {
                            currentQuizSetIndex = savedProgress.currentQuizSetIndex;
                        }
                        
                        // Restore shuffled quiz data
                        if (savedProgress.shuffledQuizData && savedProgress.shuffledQuizData.length > 0) {
                            shuffledQuizData = [];
                            for (const questionText of savedProgress.shuffledQuizData) {
                                const foundQuestion = quizData.find(q => q.question === questionText);
                                if (foundQuestion) {
                                    shuffledQuizData.push(foundQuestion);
                                }
                            }
                        }
                        
                        // Restore quiz sets if needed
                        if (typeof quizSets === 'undefined' || quizSets.length === 0) {
                            const orderedQuizData = [...quizData];
                            quizSets = [];
                            quizSetResults = [];
                            for (let i = 0; i < 17; i++) {
                                quizSets.push(orderedQuizData.slice(i * 10, (i + 1) * 10));
                                quizSetResults.push({ correct: 0, wrong: 0 });
                            }
                            quizSets.push(orderedQuizData.slice(170, 175));
                            quizSetResults.push({ correct: 0, wrong: 0 });
                        }
                        
                        // Restore UI to quiz state
                        if (paymentSection) paymentSection.style.display = 'none';
                        if (startSection) startSection.style.display = 'none';
                        if (topicSection) topicSection.style.display = 'block';
                        if (questionSection) questionSection.style.display = 'block';
                        if (answersSection) answersSection.style.display = 'flex';
                        if (nextSection) nextSection.style.display = 'none';
                        if (resultsSection) resultsSection.style.display = 'none';
                        
                        // Load the current question
                        loadQuestion();
                        
                        progressRestored = true;
                        gameInitialized = true;
                        pageInitialized = true;
                        window.name = 'quizPageInitialized_' + Date.now();
                        try {
                            sessionStorage.setItem('pageInitialized', 'true');
                            localStorage.setItem('pageInitialized', 'true');
                        } catch (e) {}
                        
                        }
                }).catch(err => {
                    });
                
                // Restore scroll position
                setTimeout(() => {
                    restoreScrollPosition();
                }, 100);
                
                return; // Don't call initGame() - we've already restored everything
            }
        }).catch(err => {
            });
    }
    
    // CRITICAL: Double-check pageUnloading flag
    // Check BOTH sessionStorage AND localStorage for maximum reliability
    let checkUnloading = false;
    try {
        // Check sessionStorage first
        checkUnloading = sessionStorage.getItem('pageUnloading') === 'true';
        if (!checkUnloading) {
            // Also check localStorage as backup
            checkUnloading = localStorage.getItem('pageUnloading') === 'true';
        }
        if (checkUnloading) {
            // Clear the flags
            try {
                sessionStorage.removeItem('pageUnloading');
                localStorage.removeItem('pageUnloading');
            } catch (e) {
                // Ignore errors
            }
            pageInitialized = true;
            isRestoringFromPageshow = true;
            wasUnloading = true;
        }
    } catch (e) {
        // sessionStorage/localStorage not available
    }
    
    // CRITICAL: Also check pageInitialized flag from sessionStorage AND localStorage (in case it was set before)
    try {
        if (sessionStorage.getItem('pageInitialized') === 'true' || localStorage.getItem('pageInitialized') === 'true') {
            pageInitialized = true;
            isRestoringFromPageshow = true;
        }
    } catch (e) {
        // sessionStorage/localStorage not available
    }
    
    // CRITICAL: Don't initialize if already initialized (check multiple methods INCLUDING initializationInProgress)
    // Check window.name first (most reliable)
    const alreadyInitialized = initializationInProgress ||
                               (window.name && window.name.includes('quizPageInitialized')) ||
                               pageInitialized ||
                               isRestoringFromPageshow ||
                               wasUnloading ||
                               checkUnloading ||
                               gameInitialized;
    
    if (!alreadyInitialized) {
        // Note: initializeEventListeners() and initializeUIButtons() already called above
        // initGame() will set all flags internally
        initGame().then(() => {
            // Restore scroll position after initialization
            setTimeout(() => {
                restoreScrollPosition();
            }, 100);
        }).catch(err => {
            // Reset flag on error
            initializationInProgress = false;
        });
    } else {
        }
}

// Also try to initialize after a short delay to ensure all elements are ready
setTimeout(() => {
    const infoBtn = document.getElementById('info-btn');
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    
    if (infoBtn) {
        // Force re-attach listener
        const infoModal = document.getElementById('info-modal');
        if (infoModal) {
            infoBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                infoModal.style.display = 'flex';
                document.body.style.overflow = 'hidden';
            }, { capture: true, passive: false });
        }
    }
    
    if (darkModeToggle) {
        darkModeToggle.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDarkMode);
        }, { capture: true, passive: false });
    }
}, 500);

// Tab switching support - save progress when switching tabs
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        // Tab is hidden, save progress
        if (gameStarted) {
            saveQuizProgress();
        }
        // CRITICAL: Set pageUnloading flag when hiding (minimize)
        // Set in BOTH sessionStorage AND localStorage for maximum reliability
        try {
            sessionStorage.setItem('pageUnloading', 'true');
            sessionStorage.setItem('pageInitialized', 'true');
            localStorage.setItem('pageUnloading', 'true'); // Also set in localStorage as backup
            localStorage.setItem('pageInitialized', 'true'); // Also set in localStorage as backup
        } catch (e) {
            // sessionStorage/localStorage not available
        }
    } else {
        // Tab is visible again, check if we need to restore
        // CRITICAL: Check if page was unloading (minimize) - if so, don't reset
        // Check BOTH sessionStorage AND localStorage for maximum reliability
        let wasUnloading = false;
        try {
            // Check sessionStorage first
            wasUnloading = sessionStorage.getItem('pageUnloading') === 'true';
            if (!wasUnloading) {
                // Also check localStorage as backup
                wasUnloading = localStorage.getItem('pageUnloading') === 'true';
            }
            if (wasUnloading) {
                // Clear the flags
                try {
                    sessionStorage.removeItem('pageUnloading');
                    localStorage.removeItem('pageUnloading');
                } catch (e) {
                    // Ignore errors
                }
                pageInitialized = true;
                isRestoringFromPageshow = true;
            }
        } catch (e) {
            // sessionStorage/localStorage not available
        }
        
        // This handles when user switches back to the tab
        const paymentCode = localStorage.getItem('paymentCode');
        if (paymentCode) {
            // CRITICAL: Check payment status if payment code exists but token doesn't
            const paymentToken = localStorage.getItem('paymentToken');
            if (!paymentToken) {
                // Payment code exists but token doesn't - need to restore payment status
                // IMPORTANT: Don't flip UI back to payment if user is already in quiz
                if (!gameStarted) {
                    checkPaymentStatus().then(paymentStatus => {
                        if (!paymentStatus.paid && !gameStarted) {
                            // Payment not verified - restore payment section
                            if (paymentSection) paymentSection.style.display = 'block';
                            if (startSection) startSection.style.display = 'none';
                            }
                    }).catch(err => {
                        });
                }
            }
            
            loadQuizProgress().then(savedProgress => {
                if (savedProgress && savedProgress.paymentCode === paymentCode && savedProgress.gameStarted) {
                    // Only restore if game was started and we have valid progress
                    if (gameStarted || savedProgress.currentQuestionIndex > 0) {
                        currentQuestionIndex = savedProgress.currentQuestionIndex || 0;
                        score = savedProgress.score || 0;
                        userAnswers = savedProgress.userAnswers || [];
                        gameStarted = savedProgress.gameStarted;
                        if (typeof currentQuizSetIndex !== 'undefined' && savedProgress.currentQuizSetIndex >= 0) {
                            currentQuizSetIndex = savedProgress.currentQuizSetIndex;
                        }
                        
                        // Restore shuffled quiz data if needed
                        if (savedProgress.shuffledQuizData && savedProgress.shuffledQuizData.length > 0 && 
                            (!shuffledQuizData || shuffledQuizData.length === 0)) {
                            shuffledQuizData = [];
                            for (const questionText of savedProgress.shuffledQuizData) {
                                const foundQuestion = quizData.find(q => q.question === questionText);
                                if (foundQuestion) {
                                    shuffledQuizData.push(foundQuestion);
                                }
                            }
                        }
                        
                        // Reload current question if we're in quiz mode
                        if (questionSection && questionSection.style.display !== 'none') {
                            loadQuestion();
                        }
                    }
                }
            }).catch(err => {
                });
        }
    }
});

// Save progress before page unload
window.addEventListener('beforeunload', function() {
    if (gameStarted) {
        saveQuizProgress();
        }
    stopSessionValidityCheck();
});

// Save progress on pagehide (for mobile browsers)
window.addEventListener('pagehide', function() {
    if (gameStarted) {
        saveQuizProgress();
        }
    stopSessionValidityCheck();
});

// NOTE: Second pageshow handler removed - progress restoration is now handled in DOMContentLoaded and initGame()
// This prevents duplicate initialization and multiple page loads
// NOTE: Duplicate functions (startNextQuizSet, showAllResults, getDeviceInfo) removed - using the ones defined earlier (around line 5510, 5550, 5603)

// ============================================
// IDLE ANIMATION SYSTEM
// ============================================
// Shows animated titles when user is idle for 1 minute 30 seconds
let idleTimer = null;
let idleAnimationActive = false;
const IDLE_TIMEOUT = 90000; // 90 seconds (1 minute 30 seconds)

// Collect all headings for animation - Great architects' powerful quotes with their images and names
const idleArchitects = [
    {
        quote: 'Ճարտարապետությունը սկսվում է այնտեղ, որտեղ ավարտվում է ինժեներությունը',
        name: 'Վալտեր Գրոպիուս',
        image: 'https://upload.wikimedia.org/wikipedia/commons/b/b5/WalterGropius-1919.jpg'
    },
    {
        quote: 'Ճարտարապետությունը արվեստ է, որը կազմակերպում է տարածությունը',
        name: 'Լե Կորբյուզիե',
        image: 'https://api.interior.ru/media/images/ARHITEKTURA/NAME/Le_Corbusier_9_12/obl_le-corbusier2.jpg'
    },
    {
        quote: 'Ճարտարապետությունը պետք է լինի պարզ, բայց ոչ պարզունակ',
        name: 'Լյուդվիգ Միս վան դեր Ռոե',
        image: 'https://losko.ru/wp-content/uploads/2018/04/Mies-Van-Der-Rohe-02-1660x1333.jpg'
    },
    {
        quote: 'Ճարտարապետությունը ձև է, ոչ թե ֆունկցիա',
        name: 'Լուիս Սալիվան',
        image: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTCzf2wMRKm9UDG69jTemMmf2WIhWJ2tSPZ8A&s'
    },
    {
        quote: 'Ճարտարապետությունը պետք է արտահայտի ժամանակը, ոչ թե հետևի նրան',
        name: 'Ֆրենկ Լլոյդ Ռայթ',
        image: 'https://avatars.mds.yandex.net/get-kinopoisk-image/1777765/f7f28303-4740-45d4-b64f-5f713f4329ad/220x330'
    },
    {
        quote: 'Ճարտարապետությունը պետք է լինի մարդու համար, ոչ թե մարդը ճարտարապետության համար',
        name: 'Ալվար Աալտո',
        image: 'https://architime.ru/pictures/aaltoalvar/big_portret.gif'
    },
    {
        quote: 'Ճարտարապետությունը պետք է լինի բնական, ոչ թե արհեստական',
        name: 'Անտոնիո Գաուդի',
        image: 'https://upload.wikimedia.org/wikipedia/commons/7/72/Antoni_Gaudi_1878.jpg'
    },
    {
        quote: 'Ճարտարապետությունը պետք է լինի հավերժական, ոչ թե ժամանակավոր',
        name: 'Օսկար Նիմեյեր',
        image: 'https://www.architectmagazine.com/wp-content/uploads/sites/5/2012/299875760-oscar-20niemeyer-tcm20-1712627.jpg?w=394'
    },
    {
        quote: 'Ճարտարապետությունը պետք է լինի գեղեցիկ, բայց նաև գործնական',
        name: 'Նորման Ֆոստեր',
        image: 'https://www.architime.ru/pictures/norman_foster/portrel_big.gif'
    },
    {
        quote: 'Ճարտարապետությունը պետք է լինի նորարարական, բայց նաև հարգալից',
        name: 'Զահա Հադիդ',
        image: 'https://upload.wikimedia.org/wikipedia/commons/7/73/Zaha_Hadid_in_Heydar_Aliyev_Cultural_center_in_Baku_nov_2013.jpg'
    }
];

// Track user activity
function resetIdleTimer() {
    if (idleAnimationActive) {
        stopIdleAnimation();
    }
    
    clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
        startIdleAnimation();
    }, IDLE_TIMEOUT);
}

// Start idle animation
function startIdleAnimation() {
    if (idleAnimationActive) return;
    
    idleAnimationActive = true;
    
    const overlay = document.getElementById('idle-animation-overlay');
    const titleContainer = document.getElementById('idle-title-container');
    const title1 = document.getElementById('idle-title-1');
    const title2 = document.getElementById('idle-title-2');
    const architectImage = document.getElementById('idle-architect-image');
    
    if (!overlay || !titleContainer || !title1 || !title2 || !architectImage) {
        return;
    }
    
    // Show overlay with darkening effect
    overlay.style.display = 'block';
    
    // Cycle through architects
    let currentArchitectIndex = 0;
    
    function showNextArchitect() {
        if (!idleAnimationActive) return;
        
        const architect = idleArchitects[currentArchitectIndex % idleArchitects.length];
        currentArchitectIndex++;
        
        // Background images removed - full black screen except text
        overlay.style.background = 'rgba(0, 0, 0, 1)'; // Full black screen
        overlay.style.backgroundImage = 'none';
        overlay.style.filter = 'none';
        overlay.style.transform = 'none';
        
        // Set titles - First title is the quote, second is the architect's name
        title1.textContent = architect.quote;
        title2.textContent = architect.name;
        
        // Set architect portrait image - circular, below the name
        const imageUrl = architect.image;
        
        // Reset image
        architectImage.src = '';
        architectImage.alt = architect.name;
        architectImage.style.display = 'block';
        architectImage.style.visibility = 'visible';
        architectImage.style.opacity = '0';
        architectImage.style.transform = 'scale(0.8)';
        
        // Load image - try multiple strategies with better fallbacks for Le Corbusier
        const tryLoadImage = (url, onSuccess, onError, attempt = 1) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            // Set timeout for each attempt (8 seconds for slower URLs like interior.ru)
            let timeout;
            
            const cleanup = () => {
                if (timeout) clearTimeout(timeout);
            };
            
            img.onload = function() {
                cleanup();
                architectImage.src = url;
                if (onSuccess) onSuccess();
            };
            
            img.onerror = function() {
                cleanup();
                // Error loading image, trying fallback
                if (attempt === 1) {
                    // Try corsproxy.io first (good for api.interior.ru)
                    tryLoadImage(`https://corsproxy.io/?${encodeURIComponent(url)}`, onSuccess, onError, 2);
                } else if (attempt === 2) {
                    // Try images.weserv.nl (good for all URLs)
                    tryLoadImage(`https://images.weserv.nl/?url=${encodeURIComponent(url)}&output=jpg`, onSuccess, onError, 3);
                } else if (attempt === 3) {
                    // Try api.allorigins.win
                    tryLoadImage(`https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`, onSuccess, onError, 4);
                } else if (attempt === 4) {
                    // Last try: images.weserv.nl without output parameter
                    tryLoadImage(`https://images.weserv.nl/?url=${encodeURIComponent(url)}`, onSuccess, onError, 5);
                } else {
                    if (onError) onError();
                }
            };
            
            timeout = setTimeout(() => {
                if (!img.complete) {
                    // Image load timeout
                    img.onerror();
                }
            }, 8000); // Increased timeout for interior.ru
            
            img.src = url;
        };
        
        // Start loading with direct URL
        tryLoadImage(imageUrl);
        
        title1.style.display = 'block';
        title1.style.opacity = '0';
        title1.style.transform = 'scale(0.5) translateY(50px)';
                title1.style.filter = 'blur(10px)';
        title1.style.transition = 'opacity 1s ease-in-out, transform 1s ease-in-out, filter 1s ease-in-out';
        
        if (title2.textContent) {
            title2.style.display = 'block';
            title2.style.opacity = '0';
            title2.style.transform = 'scale(0.5) translateY(50px)';
            title2.style.filter = 'blur(10px)';
            title2.style.transition = 'opacity 1s ease-in-out, transform 1s ease-in-out, filter 1s ease-in-out';
        }
        
        // Animate in - use requestAnimationFrame for smooth animation
        requestAnimationFrame(() => {
            setTimeout(() => {
                if (!idleAnimationActive) return;
                
                // Show quote first - ABSOLUTE MAXIMUM CLARITY - NO BLUR AT ALL - FOREGROUND
                title1.style.opacity = '1';
                title1.style.transform = 'scale(1) translateY(0) translateZ(100px)';
                title1.style.filter = 'none';
                title1.style.webkitFilter = 'none';
                title1.style.setProperty('filter', 'none', 'important');
                title1.style.setProperty('-webkit-filter', 'none', 'important');
                title1.style.setProperty('backdrop-filter', 'none', 'important');
                title1.style.setProperty('z-index', '999999', 'important');
                title1.style.setProperty('transform', 'scale(1) translateY(0) translateZ(100px)', 'important');
                title1.style.setProperty('will-change', 'transform, opacity', 'important');
                
                if (title2.textContent) {
                    setTimeout(() => {
                        if (!idleAnimationActive) return;
                        // Show name - ABSOLUTE MAXIMUM CLARITY - NO BLUR AT ALL - FOREGROUND
                        title2.style.opacity = '1';
                        title2.style.transform = 'scale(1) translateY(0) translateZ(100px)';
                        title2.style.filter = 'none';
                        title2.style.webkitFilter = 'none';
                        title2.style.setProperty('filter', 'none', 'important');
                        title2.style.setProperty('-webkit-filter', 'none', 'important');
                        title2.style.setProperty('backdrop-filter', 'none', 'important');
                        title2.style.setProperty('z-index', '999999', 'important');
                        title2.style.setProperty('transform', 'scale(1) translateY(0) translateZ(100px)', 'important');
                        title2.style.setProperty('will-change', 'transform, opacity', 'important');
                        
                        // Then show architect image below the name
                        setTimeout(() => {
                            if (!idleAnimationActive) return;
                            
                            if (architectImage && architectImage.src && architectImage.src !== '') {
                                architectImage.style.opacity = '1';
                                architectImage.style.transform = 'scale(1)';
                                architectImage.style.transition = 'all 1.5s ease-in-out';
                            }
                        }, 500);
                    }, 500);
                }
            }, 300);
        });
        
        // Hold for 8 seconds (longer display), then fade out slowly
        setTimeout(() => {
            if (!idleAnimationActive) return;
            
            // Fade out architect image first
            if (architectImage) {
                architectImage.style.opacity = '0';
                architectImage.style.transform = 'scale(0.8)';
            }
            
            title1.style.opacity = '0';
            title1.style.transform = 'scale(1.1) translateY(-20px)';
            title1.style.filter = 'blur(8px)';
            title1.style.transition = 'all 2s ease-in-out';
            
            if (title2.textContent) {
                title2.style.opacity = '0';
                title2.style.transform = 'scale(1.1) translateY(-20px)';
                title2.style.filter = 'blur(8px)';
                title2.style.transition = 'all 2s ease-in-out';
            }
            
            // Show next architect after fade out
            setTimeout(() => {
                if (idleAnimationActive) {
                    showNextArchitect();
                }
            }, 2000);
        }, 8000);
    }
    
    // Start animation cycle
    showNextArchitect();
}

// Stop idle animation
function stopIdleAnimation() {
    if (!idleAnimationActive) return;
    
    idleAnimationActive = false;
    
    const overlay = document.getElementById('idle-animation-overlay');
    const title1 = document.getElementById('idle-title-1');
    const title2 = document.getElementById('idle-title-2');
    
    if (overlay) {
        overlay.style.background = 'rgba(0, 0, 0, 1)'; // Full black screen
        overlay.style.backgroundImage = 'none';
        overlay.style.filter = 'none'; // Reset blur when stopping animation
        overlay.style.transform = 'none'; // Reset scale when stopping animation
        setTimeout(() => {
            overlay.style.display = 'none';
            if (title1) {
                title1.style.opacity = '0';
                title1.style.transform = 'scale(0.5)';
                title1.style.filter = 'blur(10px)';
            }
            if (title2) {
                title2.style.opacity = '0';
                title2.style.transform = 'scale(0.5)';
                title2.style.filter = 'blur(10px)';
            }
        }, 500);
    }
    
    resetIdleTimer();
}

// Draw face outline using SVG path - realistic continuous line art style
function drawFaceOutline(svgElement) {
    // Clear previous paths
    svgElement.innerHTML = '';
    
    // Add style definitions
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const style = document.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.textContent = `
        .face-outline {
            fill: none;
            stroke: #ffffff;
            stroke-width: 2.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke-dasharray: 2000;
            stroke-dashoffset: 2000;
            animation: drawFace 4s ease-in-out forwards;
        }
        @keyframes drawFace {
            to {
                stroke-dashoffset: 0;
            }
        }
    `;
    defs.appendChild(style);
    svgElement.appendChild(defs);
    
    // Create realistic face outline path (continuous line art style)
    const centerX = 125;
    const centerY = 125;
    const faceWidth = 90;
    const faceHeight = 130;
    
    // Realistic face outline - continuous line starting from top of head
    const facePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const faceOutline = `M ${centerX} ${centerY - faceHeight/2}
                         Q ${centerX - faceWidth/3} ${centerY - faceHeight/2.5} ${centerX - faceWidth/2.2} ${centerY - faceHeight/4}
                         Q ${centerX - faceWidth/2} ${centerY - faceHeight/6} ${centerX - faceWidth/2.5} ${centerY}
                         Q ${centerX - faceWidth/2.2} ${centerY + faceHeight/4} ${centerX - faceWidth/2.5} ${centerY + faceHeight/2.5}
                         Q ${centerX - faceWidth/4} ${centerY + faceHeight/2} ${centerX} ${centerY + faceHeight/2.2}
                         Q ${centerX + faceWidth/4} ${centerY + faceHeight/2} ${centerX + faceWidth/2.5} ${centerY + faceHeight/2.5}
                         Q ${centerX + faceWidth/2.2} ${centerY + faceHeight/4} ${centerX + faceWidth/2.5} ${centerY}
                         Q ${centerX + faceWidth/2} ${centerY - faceHeight/6} ${centerX + faceWidth/2.2} ${centerY - faceHeight/4}
                         Q ${centerX + faceWidth/3} ${centerY - faceHeight/2.5} ${centerX} ${centerY - faceHeight/2}
                         Z`;
    
    facePath.setAttribute('d', faceOutline);
    facePath.setAttribute('class', 'face-outline');
    svgElement.appendChild(facePath);
    
    // Left eyebrow
    const leftEyebrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const eyebrowLeft = `M ${centerX - 35} ${centerY - 35}
                         Q ${centerX - 25} ${centerY - 38} ${centerX - 15} ${centerY - 35}`;
    leftEyebrow.setAttribute('d', eyebrowLeft);
    leftEyebrow.setAttribute('class', 'face-outline');
    svgElement.appendChild(leftEyebrow);
    
    // Right eyebrow
    const rightEyebrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const eyebrowRight = `M ${centerX + 15} ${centerY - 35}
                          Q ${centerX + 25} ${centerY - 38} ${centerX + 35} ${centerY - 35}`;
    rightEyebrow.setAttribute('d', eyebrowRight);
    rightEyebrow.setAttribute('class', 'face-outline');
    svgElement.appendChild(rightEyebrow);
    
    // Left eye (more realistic almond shape)
    const leftEye = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const eyeLeft = `M ${centerX - 30} ${centerY - 20}
                     Q ${centerX - 25} ${centerY - 25} ${centerX - 20} ${centerY - 20}
                     Q ${centerX - 25} ${centerY - 15} ${centerX - 30} ${centerY - 20}`;
    leftEye.setAttribute('d', eyeLeft);
    leftEye.setAttribute('class', 'face-outline');
    svgElement.appendChild(leftEye);
    
    // Right eye (more realistic almond shape)
    const rightEye = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const eyeRight = `M ${centerX + 20} ${centerY - 20}
                      Q ${centerX + 25} ${centerY - 25} ${centerX + 30} ${centerY - 20}
                      Q ${centerX + 25} ${centerY - 15} ${centerX + 20} ${centerY - 20}`;
    rightEye.setAttribute('d', eyeRight);
    rightEye.setAttribute('class', 'face-outline');
    svgElement.appendChild(rightEye);
    
    // Nose (more realistic with bridge and nostrils)
    const nosePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const nose = `M ${centerX} ${centerY - 15}
                  L ${centerX} ${centerY + 5}
                  Q ${centerX - 5} ${centerY + 15} ${centerX - 8} ${centerY + 20}
                  M ${centerX} ${centerY + 5}
                  Q ${centerX + 5} ${centerY + 15} ${centerX + 8} ${centerY + 20}`;
    nosePath.setAttribute('d', nose);
    nosePath.setAttribute('class', 'face-outline');
    svgElement.appendChild(nosePath);
    
    // Mouth (more realistic with upper and lower lip)
    const mouthPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const mouth = `M ${centerX - 18} ${centerY + 35}
                   Q ${centerX - 10} ${centerY + 38} ${centerX} ${centerY + 38}
                   Q ${centerX + 10} ${centerY + 38} ${centerX + 18} ${centerY + 35}
                   M ${centerX - 18} ${centerY + 35}
                   Q ${centerX} ${centerY + 42} ${centerX + 18} ${centerY + 35}`;
    mouthPath.setAttribute('d', mouth);
    mouthPath.setAttribute('class', 'face-outline');
    svgElement.appendChild(mouthPath);
    
    // Jawline definition
    const jawline = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const jaw = `M ${centerX - faceWidth/2.5} ${centerY + faceHeight/2.5}
                 Q ${centerX - faceWidth/4} ${centerY + faceHeight/2.2} ${centerX} ${centerY + faceHeight/2.2}
                 Q ${centerX + faceWidth/4} ${centerY + faceHeight/2.2} ${centerX + faceWidth/2.5} ${centerY + faceHeight/2.5}`;
    jawline.setAttribute('d', jaw);
    jawline.setAttribute('class', 'face-outline');
    svgElement.appendChild(jawline);
    
    // Neck and shoulders
    const neckPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const neck = `M ${centerX - faceWidth/3} ${centerY + faceHeight/2.2}
                  L ${centerX - 25} ${centerY + faceHeight/1.5}
                  L ${centerX - 40} ${centerY + faceHeight/1.3}
                  M ${centerX + faceWidth/3} ${centerY + faceHeight/2.2}
                  L ${centerX + 25} ${centerY + faceHeight/1.5}
                  L ${centerX + 40} ${centerY + faceHeight/1.3}
                  M ${centerX - 40} ${centerY + faceHeight/1.3}
                  Q ${centerX} ${centerY + faceHeight/1.2} ${centerX + 40} ${centerY + faceHeight/1.3}`;
    neckPath.setAttribute('d', neck);
    neckPath.setAttribute('class', 'face-outline');
    svgElement.appendChild(neckPath);
}

// Initialize idle detection
function initIdleDetection() {
    // Reset timer on any user activity
    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click', 'keydown'];
    
    events.forEach(event => {
        document.addEventListener(event, resetIdleTimer, { passive: true });
        window.addEventListener(event, resetIdleTimer, { passive: true });
    });
    
    // Start the timer
    resetIdleTimer();
}

// NOTE: Duplicate code block removed (was at line 7368-7965)
// All duplicate functions, initialization code, and pageshow handlers have been removed.
// These are already defined earlier in the file (around line 5808, 5997, 6204, 6284, etc.)
// Duplicate code was causing button event listeners to not work properly

// Expose functions globally for onclick attributes in HTML
// This ensures that onclick="functionName()" in HTML can access these functions
// Must be at the end of the file after all functions are defined
// CRITICAL: Expose functions immediately, even before DOMContentLoaded
if (typeof window !== 'undefined') {
    window.startQuiz = startQuiz;
    window.verifyPaymentCode = verifyPaymentCode;
    window.nextQuestion = nextQuestion;
    window.showAnswersReview = showAnswersReview;
    window.repeatQuiz = repeatQuiz;
    window.startNextQuizSet = startNextQuizSet;
    window.showAllResults = showAllResults;
    window.handleInfoClick = handleInfoClick;
    window.handleDarkModeToggle = handleDarkModeToggle;
    window.copyToClipboard = copyToClipboard;
    window.submitPaymentRequest = submitPaymentRequest;
    
    // Expose idle animation functions for manual testing
    window.startIdleAnimation = startIdleAnimation;
    window.stopIdleAnimation = stopIdleAnimation;
    window.resetIdleTimer = resetIdleTimer;
    
    // CRITICAL: If DOM is already loaded (Netlify production), initialize immediately
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        // DOM is already loaded, initialize event listeners immediately
        if (typeof initializeEventListeners === 'function' && typeof eventListenersInitialized !== 'undefined' && !eventListenersInitialized) {
            try {
                initializeEventListeners();
            } catch (e) {
                // Ignore errors, DOMContentLoaded will handle it
            }
        }
        if (typeof initializeUIButtons === 'function' && typeof uiButtonsInitialized !== 'undefined' && !uiButtonsInitialized) {
            try {
                initializeUIButtons();
            } catch (e) {
                // Ignore errors, DOMContentLoaded will handle it
            }
        }
    }
}
